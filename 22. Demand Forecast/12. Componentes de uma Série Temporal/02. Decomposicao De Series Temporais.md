## Decomposi√ß√£o de S√©ries Temporais: Uma An√°lise Detalhada

### Introdu√ß√£o
Em continuidade ao nosso estudo sobre previs√£o de demanda no setor de sa√∫de, a an√°lise de s√©ries temporais √© essencial para a modelagem e previs√£o de padr√µes de demanda [^1]. Uma s√©rie temporal pode ser decomposta em quatro componentes principais: **tend√™ncia**, **ciclo**, **sazonalidade** e **irregularidade** [^3]. Esta decomposi√ß√£o √© crucial para compreender os padr√µes subjacentes nos dados, permitindo a aplica√ß√£o de t√©cnicas de previs√£o mais precisas e eficazes. No cap√≠tulo anterior, introduzimos esses componentes e suas caracter√≠sticas b√°sicas. Neste cap√≠tulo, aprofundaremos a an√°lise matem√°tica e estat√≠stica por tr√°s da decomposi√ß√£o de s√©ries temporais, focando na identifica√ß√£o e modelagem de cada componente.

### Modelagem Matem√°tica dos Componentes de S√©ries Temporais

#### 1. Tend√™ncia
A tend√™ncia reflete um movimento de longo prazo nos dados, que pode ser modelado usando regress√£o linear, polinomial ou m√©todos de suaviza√ß√£o [Proposi√ß√£o 1.1]. Exploraremos a modelagem matem√°tica destas abordagens:

##### 1.1 Regress√£o Linear
A regress√£o linear assume que a tend√™ncia pode ser representada por uma linha reta. A equa√ß√£o geral para a tend√™ncia em um per√≠odo $t$ √© dada por:
$$T_t = a + bt$$
onde:
- $T_t$ √© a tend√™ncia no per√≠odo $t$.
- $a$ √© o intercepto da linha de tend√™ncia, representando o valor da tend√™ncia quando $t=0$.
- $b$ √© o coeficiente angular, indicando a taxa de mudan√ßa na tend√™ncia por unidade de tempo.

Os par√¢metros $a$ e $b$ s√£o estimados minimizando a soma dos quadrados das diferen√ßas entre os valores observados e os valores previstos pela linha de tend√™ncia. Em nota√ß√£o matricial, o modelo de regress√£o linear pode ser escrito como:
$$Y = X\beta + \epsilon$$
onde:
- $Y$ √© o vetor de valores observados da s√©rie temporal.
- $X$ √© a matriz de design, com a primeira coluna sendo um vetor de 1's (para o intercepto) e a segunda coluna contendo os valores de tempo $t$.
- $\beta$ √© o vetor de coeficientes de regress√£o (incluindo $a$ e $b$).
- $\epsilon$ √© o vetor de erros aleat√≥rios.
A estimativa de $\beta$ pode ser obtida atrav√©s da f√≥rmula:
$$\hat{\beta} = (X^TX)^{-1}X^TY$$
onde $(X^TX)^{-1}$ √© a inversa da matriz $(X^TX)$.

**Prova da Estimativa de Œ≤:**
Provaremos que a estimativa do vetor de coeficientes de regress√£o $\beta$ √© dada por $\hat{\beta} = (X^TX)^{-1}X^TY$.

I. Come√ßamos com o modelo de regress√£o linear na forma matricial:
   $$Y = X\beta + \epsilon$$
   onde $Y$ √© o vetor de valores observados, $X$ √© a matriz de design, $\beta$ √© o vetor de coeficientes, e $\epsilon$ √© o vetor de erros.

II. O objetivo √© encontrar o vetor $\hat{\beta}$ que minimize a soma dos quadrados dos erros, dada por:
   $$SSE = \epsilon^T \epsilon = (Y - X\beta)^T(Y - X\beta)$$

III. Expandindo a equa√ß√£o, obtemos:
   $$SSE = (Y^T - \beta^T X^T)(Y - X\beta) = Y^TY - Y^TX\beta - \beta^TX^TY + \beta^TX^TX\beta$$
    Como $Y^TX\beta$ √© um escalar, $Y^TX\beta = (Y^TX\beta)^T = \beta^TX^TY$. Portanto,
    $$SSE = Y^TY - 2\beta^TX^TY + \beta^TX^TX\beta$$

IV. Para encontrar o m√≠nimo, derivamos $SSE$ em rela√ß√£o a $\beta$ e igualamos a zero:
   $$\frac{\partial SSE}{\partial \beta} = -2X^TY + 2X^TX\beta = 0$$

V. Resolvendo para $\beta$, obtemos:
    $$2X^TX\beta = 2X^TY$$
    $$X^TX\beta = X^TY$$

VI. Finalmente, multiplicamos ambos os lados pela inversa de $(X^TX)$, assumindo que ela existe:
    $$\hat{\beta} = (X^TX)^{-1}X^TY$$
Portanto, demonstramos que a estimativa de $\beta$ que minimiza a soma dos quadrados dos erros √© dada por $\hat{\beta} = (X^TX)^{-1}X^TY$. ‚ñ†

> üí° **Exemplo Num√©rico:** Suponha que temos os seguintes dados de demanda de pacientes em um hospital ao longo de 5 semanas: [250, 265, 280, 295, 310].  Vamos aplicar regress√£o linear para modelar a tend√™ncia.
```python
import numpy as np
from sklearn.linear_model import LinearRegression

# Dados de demanda
y = np.array([250, 265, 280, 295, 310])
t = np.array([0, 1, 2, 3, 4]).reshape(-1, 1) # Tempo como vari√°vel independente

# Criar matriz X com coluna de 1s e coluna de tempo t
X = np.concatenate((np.ones((len(t), 1)), t), axis=1)

# Calcular beta usando a f√≥rmula
beta_hat = np.linalg.inv(X.T @ X) @ X.T @ y
print(f"Estimativa de beta (a, b): {beta_hat}")

# Usando sklearn para compara√ß√£o
model = LinearRegression()
model.fit(t, y)
print(f"Estimativa de beta (a, b) usando sklearn: Intercepto={model.intercept_}, Coeficiente={model.coef_[0]}")
```
Resultado: `Estimativa de beta (a, b): [250.  15.]`, e usando sklearn, `Estimativa de beta (a, b) usando sklearn: Intercepto=250.0, Coeficiente=15.0`. Isso significa que a tend√™ncia estimada √© $T_t = 250 + 15t$. O intercepto $a = 250$ representa a demanda inicial, e o coeficiente angular $b = 15$ significa que a demanda cresce em m√©dia 15 pacientes por semana. Podemos plotar os valores reais e a linha de tend√™ncia para visualizar a adequa√ß√£o do modelo.
```mermaid
graph LR
    A[Tempo] --> B(Demanda);
    C[Tempo] --> D(Tend√™ncia Linear);
    B -- Valores Reais --> E;
    D -- Linha de Tend√™ncia --> E;
    E[Gr√°fico]
```
<!-- An√°lise de Res√≠duos: Verifica√ß√£o de qu√£o bem o modelo linear se encaixa nos dados. Os res√≠duos devem ser distribu√≠dos aleatoriamente em torno de zero, indicando um bom ajuste -->

##### 1.2 Regress√£o Polinomial
Em casos onde a tend√™ncia n√£o √© linear, a regress√£o polinomial pode ser utilizada para modelar a tend√™ncia como uma curva. A equa√ß√£o geral de um polin√¥mio de grau $n$ para a tend√™ncia √©:
$$T_t = a_0 + a_1t + a_2t^2 + \ldots + a_nt^n$$
onde:
- $T_t$ √© a tend√™ncia no per√≠odo $t$.
- $a_0, a_1, \ldots, a_n$ s√£o os par√¢metros do polin√¥mio.
- $t$ √© o √≠ndice de tempo.

Os coeficientes $a_i$ s√£o estimados de forma similar √† regress√£o linear, mas envolvendo um ajuste polinomial aos dados. A complexidade do modelo aumenta com o grau $n$ do polin√¥mio, o que pode levar a overfitting se n√£o ajustado corretamente.

> üí° **Exemplo Num√©rico:** Suponha que a demanda ao longo de 6 per√≠odos seja [100, 120, 160, 210, 280, 360]. Uma regress√£o linear pode n√£o se ajustar bem, pois a taxa de crescimento aumenta. Vamos usar um polin√¥mio de grau 2.
```python
import numpy as np
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

# Dados de demanda
y = np.array([100, 120, 160, 210, 280, 360])
t = np.array([0, 1, 2, 3, 4, 5]).reshape(-1, 1)

# Criar transforma√ß√µes polinomiais
poly = PolynomialFeatures(degree=2)
X = poly.fit_transform(t)

# Ajustar modelo de regress√£o
model = LinearRegression()
model.fit(X, y)
print(f"Coeficientes polinomiais (a0, a1, a2): {model.intercept_}, {model.coef_[1:]}")

# Visualiza√ß√£o
t_plot = np.linspace(0, 5, 100).reshape(-1,1)
X_plot = poly.transform(t_plot)
y_plot = model.predict(X_plot)
plt.scatter(t, y, label='Dados Reais')
plt.plot(t_plot, y_plot, color='red', label='Tend√™ncia Polinomial')
plt.xlabel('Tempo (t)')
plt.ylabel('Demanda')
plt.legend()
plt.show()

```
Resultados: `Coeficientes polinomiais (a0, a1, a2): 103.33333333333331, [11.66666667 10.        ]`. O modelo de tend√™ncia polinomial √© ent√£o $T_t = 103.33 + 11.67t + 10t^2$. A visualiza√ß√£o mostra a curva que se ajusta melhor aos dados do que uma linha reta, evidenciando a utilidade da regress√£o polinomial quando h√° acelera√ß√£o na tend√™ncia.
<!-- An√°lise de Res√≠duos: Similar √† regress√£o linear, os res√≠duos devem ser analisados para verificar a adequa√ß√£o do modelo polinomial. -->

##### 1.3 Suaviza√ß√£o por M√©dias M√≥veis
A suaviza√ß√£o por m√©dias m√≥veis √© um m√©todo n√£o param√©trico que suaviza flutua√ß√µes de curto prazo, revelando a tend√™ncia subjacente [Proposi√ß√£o 1.1]. A m√©dia m√≥vel simples (SMA) para um per√≠odo $t$ √© calculada como:
$$SMA_t = \frac{1}{k} \sum_{i=t-k+1}^{t} Y_i$$
onde:
- $SMA_t$ √© a m√©dia m√≥vel no per√≠odo $t$.
- $k$ √© o tamanho da janela da m√©dia m√≥vel.
- $Y_i$ √© o valor da s√©rie temporal no per√≠odo $i$.
Em ess√™ncia, a SMA calcula a m√©dia de $k$ pontos de dados anteriores a $t$.

>üí° **Exemplo Num√©rico:**  Vamos usar os dados de demanda do exemplo anterior [250, 265, 280, 295, 310] e aplicar uma m√©dia m√≥vel com janela de tamanho 3.
```python
import numpy as np
import pandas as pd

# Dados de demanda
y = np.array([250, 265, 280, 295, 310])
data = pd.Series(y)

# Calcular m√©dia m√≥vel com janela de 3
sma = data.rolling(window=3).mean()
print(f"M√©dia M√≥vel (k=3): {sma.to_list()}")

```
Resultado: `M√©dia M√≥vel (k=3): [nan, nan, 265.0, 280.0, 295.0]`. Os dois primeiros valores s√£o `NaN` porque n√£o h√° dados suficientes para calcular a m√©dia m√≥vel com janela de 3 para os primeiros dois pontos. A suaviza√ß√£o por m√©dias m√≥veis nos d√° uma representa√ß√£o mais suave da tend√™ncia subjacente.

>üí° **Reflex√£o sobre a escolha do m√©todo:** A escolha entre regress√£o linear, polinomial e suaviza√ß√£o por m√©dias m√≥veis depende da natureza da tend√™ncia. Regress√£o linear √© adequada para tend√™ncias lineares, enquanto regress√£o polinomial pode capturar tend√™ncias n√£o lineares. M√©todos de suaviza√ß√£o s√£o flex√≠veis, por√©m, menos param√©tricos, e podem ser mais robustos a varia√ß√µes.

**Lema 1.1:** A m√©dia m√≥vel ponderada (WMA) √© uma extens√£o da m√©dia m√≥vel simples, onde cada observa√ß√£o dentro da janela recebe um peso diferente. A f√≥rmula para a WMA no per√≠odo *t* √© dada por:
$$WMA_t = \sum_{i=t-k+1}^{t} w_i Y_i$$
onde:
- $WMA_t$ √© a m√©dia m√≥vel ponderada no per√≠odo *t*.
- $k$ √© o tamanho da janela da m√©dia m√≥vel.
- $Y_i$ √© o valor da s√©rie temporal no per√≠odo *i*.
- $w_i$ s√£o os pesos atribu√≠dos a cada observa√ß√£o, de forma que $\sum_{i=t-k+1}^{t} w_i = 1$.

A escolha dos pesos $w_i$ permite dar mais import√¢ncia a certos valores da janela, como os mais recentes, o que pode ser √∫til para capturar mudan√ßas na tend√™ncia de forma mais r√°pida.

> üí° **Exemplo Num√©rico:** Usando novamente os dados [250, 265, 280, 295, 310], vamos calcular a WMA com janela 3 e pesos [0.2, 0.3, 0.5].
```python
import numpy as np
import pandas as pd

# Dados de demanda
y = np.array([250, 265, 280, 295, 310])
data = pd.Series(y)
weights = [0.2, 0.3, 0.5]

# Fun√ß√£o para calcular a WMA
def weighted_moving_average(series, weights):
    wma = []
    for i in range(len(series)):
        if i < len(weights) - 1:
            wma.append(np.nan)
        else:
          window = series[i-len(weights)+1:i+1]
          wma.append(np.dot(window, weights))
    return wma

wma = weighted_moving_average(data, weights)
print(f"M√©dia M√≥vel Ponderada (k=3, pesos=[0.2, 0.3, 0.5]): {wma}")
```
Resultado: `M√©dia M√≥vel Ponderada (k=3, pesos=[0.2, 0.3, 0.5]): [nan, nan, 272.5, 287.5, 302.5]`. A WMA d√° mais peso aos dados mais recentes, tornando-a mais responsiva a mudan√ßas na tend√™ncia do que a SMA.

#### 2. Ciclo
Os ciclos s√£o varia√ß√µes de longo prazo que ocorrem em intervalos de tempo maiores que a sazonalidade, afetados por fatores econ√¥micos e pol√≠ticos [^3, Lema 2.1]. A modelagem matem√°tica de ciclos √© mais complexa devido √† sua natureza irregular e imprevis√≠vel.

##### 2.1 An√°lise Espectral
A an√°lise espectral √© uma t√©cnica que decomp√µe uma s√©rie temporal em seus componentes de frequ√™ncia, permitindo a identifica√ß√£o de padr√µes c√≠clicos. A transformada de Fourier √© uma ferramenta fundamental nesta an√°lise. A transformada de Fourier de uma s√©rie temporal $Y_t$ √© definida como:
$$X_k = \sum_{t=0}^{N-1} Y_t e^{-j2\pi kt/N}$$
onde:
- $X_k$ √© a componente de frequ√™ncia da s√©rie temporal no √≠ndice $k$.
- $N$ √© o tamanho da s√©rie temporal.
- $j$ √© a unidade imagin√°ria.

A an√°lise do espectro de frequ√™ncia permite a identifica√ß√£o de componentes c√≠clicos atrav√©s dos picos nas diferentes frequ√™ncias. Ciclos comumente apresentam frequ√™ncias menores e podem ser analisados com as t√©cnicas citadas anteriormente.

> üí° **Exemplo Num√©rico:** Vamos criar uma s√©rie temporal simulada com um ciclo e usar a transformada de Fourier para identificar a frequ√™ncia do ciclo.
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft

# Criar s√©rie temporal simulada com um ciclo
N = 100  # N√∫mero de pontos de dados
t = np.arange(N)
freq_ciclo = 0.1  # Frequ√™ncia do ciclo
y = 10 * np.sin(2 * np.pi * freq_ciclo * t) + np.random.normal(0, 2, N)

# Calcular a FFT
fft_result = fft(y)
fft_freq = np.fft.fftfreq(N, 1)

# Calcular o espectro de pot√™ncia (magnitude)
fft_magnitude = np.abs(fft_result)

# Encontrar a frequ√™ncia com maior amplitude
peak_freq_index = np.argmax(fft_magnitude[1:N//2]) + 1  # Ignora a frequ√™ncia 0
peak_freq = fft_freq[peak_freq_index]
print(f"Frequ√™ncia do ciclo identificada: {peak_freq}")

# Plotar o espectro
plt.plot(fft_freq[0:N//2], fft_magnitude[0:N//2])
plt.xlabel('Frequ√™ncia')
plt.ylabel('Magnitude')
plt.title('Espectro de Frequ√™ncia')
plt.show()

```
Resultado: A frequ√™ncia do ciclo identificada deve ser aproximadamente 0.1. O gr√°fico mostra picos em certas frequ√™ncias, indicando as componentes c√≠clicas dominantes. Este exemplo demonstra como a an√°lise espectral pode identificar a frequ√™ncia de ciclos presentes em uma s√©rie temporal.

##### 2.2 Modelos de S√©ries Temporais com Componentes C√≠clicos
Modelos de s√©ries temporais como AR (AutoRegressivo) e MA (M√©dias M√≥veis) podem ser utilizados para modelar ciclos, especialmente quando eles apresentam autocorrela√ß√£o. Um modelo AR(p) modela a s√©rie temporal como uma fun√ß√£o linear dos seus valores passados:
$$Y_t = c + \sum_{i=1}^{p} \phi_i Y_{t-i} + \epsilon_t$$
onde:
- $Y_t$ √© o valor da s√©rie temporal no per√≠odo $t$.
- $c$ √© uma constante.
- $\phi_i$ s√£o os coeficientes auto-regressivos.
- $p$ √© a ordem do modelo.
- $\epsilon_t$ √© o erro aleat√≥rio.

Um modelo MA(q) modela a s√©rie temporal como uma fun√ß√£o linear dos seus erros passados:
$$Y_t = \mu + \sum_{i=1}^{q} \theta_i \epsilon_{t-i} + \epsilon_t$$
onde:
- $Y_t$ √© o valor da s√©rie temporal no per√≠odo $t$.
- $\mu$ √© a m√©dia da s√©rie.
- $\theta_i$ s√£o os coeficientes de m√©dias m√≥veis.
- $q$ √© a ordem do modelo.
- $\epsilon_t$ √© o erro aleat√≥rio.

>üí° **Reflex√£o sobre a Modelagem de Ciclos:** Modelar ciclos √© complexo devido √† sua natureza irregular e √† influ√™ncia de fatores externos. T√©cnicas espectrais s√£o √∫teis para identificar ciclos, enquanto modelos AR e MA podem ser usados para modelar ciclos com autocorrela√ß√£o.

**Proposi√ß√£o 2.1:** Modelos ARMA (AutoRegressivo de M√©dias M√≥veis) combinam as caracter√≠sticas dos modelos AR e MA, permitindo a modelagem de s√©ries temporais com autocorrela√ß√£o tanto em seus valores passados quanto em seus erros passados. A estrutura geral de um modelo ARMA(p, q) √© dada por:
$$Y_t = c + \sum_{i=1}^{p} \phi_i Y_{t-i} + \sum_{i=1}^{q} \theta_i \epsilon_{t-i} + \epsilon_t$$
onde:
- $Y_t$ √© o valor da s√©rie temporal no per√≠odo $t$.
- $c$ √© uma constante.
- $\phi_i$ s√£o os coeficientes auto-regressivos.
- $p$ √© a ordem do componente AR.
- $\theta_i$ s√£o os coeficientes de m√©dias m√≥veis.
- $q$ √© a ordem do componente MA.
- $\epsilon_t$ √© o erro aleat√≥rio.

Modelos ARMA s√£o mais flex√≠veis do que modelos AR ou MA separadamente e podem modelar uma variedade maior de padr√µes de autocorrela√ß√£o.

> üí° **Exemplo Num√©rico:** Para ilustrar um modelo AR(1), vamos usar dados simulados.
```python
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA

# Simular dados com comportamento AR(1)
N = 100
phi = 0.7 # Coeficiente AR
epsilon = np.random.normal(0, 1, N)
y = np.zeros(N)
y[0] = epsilon[0] # valor inicial
for t in range(1,N):
    y[t] = phi * y[t-1] + epsilon[t]

# Ajustar modelo AR(1) usando statsmodels
model = ARIMA(y, order=(1, 0, 0))
model_fit = model.fit()
print(f"Coeficiente AR(1) estimado: {model_fit.params[1]}")

# Plotar dados e predi√ß√µes
plt.plot(y, label="S√©rie Temporal Simualda")
plt.plot(model_fit.fittedvalues, color='red', label="Ajuste AR(1)")
plt.legend()
plt.show()
```
Resultado: O coeficiente AR(1) estimado deve ser pr√≥ximo a 0.7 (dependendo do ru√≠do aleat√≥rio). O gr√°fico mostra como o modelo AR(1) consegue modelar a s√©rie temporal simulada.

#### 3. Sazonalidade
A sazonalidade corresponde a um padr√£o que se repete dentro de um per√≠odo fixo [^3, Teorema 3.1]. A modelagem matem√°tica da sazonalidade pode ser feita atrav√©s de s√©ries de Fourier e modelos SARIMA.

##### 3.1 S√©ries de Fourier
Como previamente mencionado [Teorema 3.1], s√©ries de Fourier permitem representar a componente sazonal como uma soma de senos e cossenos de diferentes frequ√™ncias:
$$S_t = \frac{a_0}{2} + \sum_{n=1}^{N} \left[ a_n \cos \left( \frac{2 \pi n t}{T} \right) + b_n \sin \left( \frac{2 \pi n t}{T} \right) \right]$$
onde:
- $S_t$ √© a componente sazonal no tempo $t$.
- $T$ √© o per√≠odo da sazonalidade.
- $a_n$ e $b_n$ s√£o os coeficientes de Fourier.
- $n$ √© a frequ√™ncia harm√¥nica.
O n√∫mero de termos $N$ determina a precis√£o da aproxima√ß√£o da componente sazonal.

> üí° **Exemplo Num√©rico:** Criemos dados simulados com sazonalidade e ajustemos uma s√©rie de Fourier para aproximar essa sazonalidade.
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, ifft

# Dados com sazonalidade
N = 100 # pontos de dados
T = 20  # Per√≠odo da sazonalidade
t = np.arange(N)
y = 5 * np.sin(2 * np.pi * t / T) + np.random.normal(0,1,N)

# C√°lculo da FFT
fft_result = fft(y)

# Definir n√∫mero de termos de Fourier para aproximar (harm√¥nicas)
num_harmonics = 3
fft_result[num_harmonics+1:len(fft_result) - num_harmonics] = 0  # Filtro

# Inversa da FFT (transforma√ß√£o para s√©rie temporal)
y_fourier = ifft(fft_result)

# Plotar resultados
plt.plot(t, y, label="Dados originais")
plt.plot(t, y_fourier.real, color="red", label="S√©rie de Fourier (N=3)")
plt.xlabel("Tempo")
plt.ylabel("Valor da S√©rie")
plt.legend()
plt.show()
```
O gr√°fico mostra a s√©rie temporal original com uma componente sazonal e o ajuste com a s√©rie de Fourier. A s√©rie de Fourier consegue aproximar a sazonalidade com poucos termos, demonstrando a sua capacidade de modelar padr√µes peri√≥dicos.
<!-- An√°lise de Res√≠duos: os res√≠duos entre os dados originais e os ajustados devem ser analisados para garantir a adequa√ß√£o do modelo -->

##### 3.2 Modelos SARIMA
Os modelos SARIMA estendem os modelos ARIMA, incluindo termos sazonais. A estrutura geral de um modelo SARIMA √© dada por:
$$ARIMA(p, d, q)(P, D, Q)_s$$
onde:
- $(p, d, q)$ s√£o os par√¢metros n√£o sazonais da componente ARIMA.
- $(P, D, Q)$ s√£o os par√¢metros sazonais da componente ARIMA.
- $s$ √© o per√≠odo da sazonalidade.

Modelos SARIMA capturam tanto a autocorrela√ß√£o da s√©rie temporal como tamb√©m as varia√ß√µes sazonais. Por exemplo, um SARIMA(1,1,1)(1,1,1)$_{12}$ indicaria um modelo auto-regressivo integrado de m√©dias m√≥veis (ARIMA) de primeira ordem para componentes n√£o sazonais (p, d e q), juntamente com um componente SARIMA de primeira ordem para componentes sazonais (P, D e Q), com uma sazonalidade de 12 per√≠odos (anual).

>üí° **Exemplo Num√©rico:** Vamos simular dados com sazonalidade anual e ajustar um modelo SARIMA(1,1,1)(1,1,1)$_{12}$.
```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX

# Simular dados com sazonalidade anual
N = 100
t = np.arange(N)
s = 12 # Periodo
y = 10*np.sin(2*np.pi*t/s) + 0.5 * t + np.random.normal(0,1,N) # Sazonalidade + tend√™ncia + ruido
data = pd.Series(y)

# Ajustar o modelo SARIMA(1,1,1)(1,1,1)12
model = SARIMAX(data, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12))
model_fit = model.fit()
print(model_fit.summary())

# Plotar resultados
plt.plot(data, label="Dados originais")
plt.plot(model_fit.fittedvalues, color="red", label="SARIMA")
plt.legend()
plt.show()
```
O `print(model_fit.summary())` mostrar√° os par√¢metros estimados pelo modelo SARIMA. O gr√°fico mostra como o modelo SARIMA se ajusta aos dados simulados com sazonalidade e tend√™ncia, mostrando que consegue capturar a componente sazonal.
<!-- An√°lise de Res√≠duos: Os res√≠duos do modelo devem ser analisados para garantir que o modelo est√° capturando toda a sazonalidade adequadamente. -->

>üí° **Reflex√£o sobre Modelagem da Sazonalidade:** S√©ries de Fourier s√£o vers√°teis para modelar m√∫ltiplas frequ√™ncias sazonais, enquanto modelos SARIMA s√£o adequados para padr√µes sazonais complexos e autocorrela√ß√£o. A escolha entre os dois depender√° da complexidade e da autocorrela√ß√£o da s√©rie temporal.

**Teorema 3.1:** A Transformada de Fourier Discreta (DFT) √© uma ferramenta que permite decompor uma s√©rie temporal em componentes de frequ√™ncia. Para uma s√©rie temporal discreta $y_t$ de comprimento $N$, a DFT √© dada por:
$$X_k = \sum_{t=0}^{N-1} y_t e^{-j2\pi kt/N}$$
onde:
- $X_k$ √© o valor da DFT na frequ√™ncia $k$.
- $j$ √© a unidade imagin√°ria.
- $k$ varia de 0 a $N-1$.

**Prova da Transformada de Fourier Discreta (DFT):**
Provaremos a forma da DFT e sua rela√ß√£o com a decomposi√ß√£o em frequ√™ncias.

I. Considere uma s√©rie temporal discreta $y_t$, onde $t$ varia de $0$ a $N-1$, representando $N$ pontos de dados.

II. A Transformada de Fourier Discreta (DFT) transforma esta s√©rie temporal no dom√≠nio do tempo para o dom√≠nio da frequ√™ncia, representando a s√©rie como uma soma de exponenciais complexas. A express√£o da DFT √©:
$$X_k = \sum_{t=0}^{N-1} y_t e^{-j2\pi kt/N}$$
onde:
- $X_k$ representa a componente de frequ√™ncia da s√©rie temporal no √≠ndice $k$.
- $j$ √© a unidade imagin√°ria, tal que $j^2 = -1$.
- $k$ varia de $0$ a $N-1$, representando as frequ√™ncias discretas.
- $e^{-j2\pi kt/N}$ √© uma exponencial complexa que representa a frequ√™ncia.

III. A exponencial complexa pode ser expandida utilizando a f√≥rmula de Euler:
$$e^{-j2\pi kt/N} = \cos\left(\frac{2\pi kt}{N}\right) - j\sin\left(\frac{2\pi kt}{N}\right)$$
A substitui√ß√£o dessa identidade na express√£o original da DFT revela que a DFT decomp√µe a s√©rie temporal em componentes de cosseno e seno de diferentes frequ√™ncias.

IV. A magnitude de $X_k$, denotada como $|X_k|$, representa a amplitude da componente de frequ√™ncia $k$. Picos em $|X_k|$ indicam as frequ√™ncias dominantes na s√©rie temporal. A frequ√™ncia $k$ √© dada por $f_k = \frac{k}{N\Delta t}$, onde $\Delta t$ √© o intervalo de amostragem.

V. Portanto, a DFT decomp√µe a s√©rie temporal $y_t$ em componentes de diferentes frequ√™ncias, expressas por $X_k$. Analisando a magnitude $|X_k|$ para diferentes valores de $k$, podemos identificar as frequ√™ncias dominantes e, em particular, as componentes sazonais na s√©rie temporal.

Assim, demonstramos como a DFT transforma a s√©rie temporal do dom√≠nio do tempo para o dom√≠nio da frequ√™ncia, permitindo identificar as frequ√™ncias dominantes, incluindo as componentes sazonais. ‚ñ†

A DFT transforma a s√©rie temporal do dom√≠nio do tempo para o dom√≠nio da frequ√™ncia, permitindo identificar as frequ√™ncias dominantes, incluindo as componentes sazonais. A an√°lise da magnitude $|X_k|$ pode revelar picos nas frequ√™ncias correspondentes a ciclos e sazonalidades.

#### 4. Irregularidade
A irregularidade √© um componente aleat√≥rio e n√£o previs√≠vel [^3, Proposi√ß√£o 4.1]. Em termos matem√°ticos, a irregularidade √© geralmente modelada como um ru√≠do branco:
$$\epsilon_t \sim N(0, \sigma^2)$$
onde:
- $\epsilon_t$ √© o componente irregular no tempo $t$.
- $N(0, \sigma^2)$ indica que o ru√≠do √© uma vari√°vel aleat√≥ria com distribui√ß√£o normal, m√©dia zero e vari√¢ncia $\sigma^2$.

##### 4.1 Filtro de Kalman
O filtro de Kalman √© um algoritmo recursivo que estima o estado de um sistema din√¢mico a partir de medi√ß√µes ruidosas [Proposi√ß√£o 4.1]. Ele modela a evolu√ß√£o do estado como um processo de Markov, usando as equa√ß√µes de transi√ß√£o e observa√ß√£o:

Equa√ß√£o de Estado:
$$x_t = Fx_{t-1} + Bu_t + w_t$$
Equa√ß√£o de Observa√ß√£o:
$$z_t = Hx_t + v_t$$
Onde:
- $x_t$ √© o vetor de estado no tempo $t$.
- $F$ √© a matriz de transi√ß√£o de estado.
- $u_t$ √© o vetor de controle.
- $B$ √© a matriz de controle.
- $w_t$ √© o ru√≠do do processo (process noise), normalmente uma vari√°vel aleat√≥ria com m√©dia zero e vari√¢ncia $Q$.
- $z_t$ √© o vetor de observa√ß√£o no tempo $t$.
- $H$ √© a matriz de observa√ß√£o.
- $v_t$ √© o ru√≠do de medi√ß√£o (measurement noise), normalmente uma vari√°vel aleat√≥ria com m√©dia zero e vari√¢ncia $R$.
O filtro de Kalman usa estas equa√ß√µes para estimar o estado $x_t$ e mitigar o ru√≠do nos dados atrav√©s da pondera√ß√£o das predi√ß√µes do modelo com as novas observa√ß√µes.

> üí° **Exemplo Num√©rico:** Vamos simular uma s√©rie temporal com ru√≠do e aplicar um filtro de Kalman simples para suavizar a s√©rie.
```python
import numpy as np
import matplotlib.pyplot as plt
from pykalman import KalmanFilter

# Gerar dados com ru√≠do
N = 100
t = np.arange(N)
y_true = 0.5 * t
y_observed = y_true + np.random.normal(0, 5, N) # Ru√≠do

# Definir o modelo de Kalman
kf = KalmanFilter(
    transition_matrices = [[1]],  # Estado x_t = x_{t-1} (sem tend√™ncia no estado)
    observation_matrices = [[1]], # Observacao z_t = x_t
    initial_state_mean = 0,  # Valor inicial do estado
    initial_state_covariance = 1, # Incerteza inicial do estado
    observation_covariance = 25, # Ru√≠do de observa√ß√£o (R)
    transition_covariance = 1 # Ru√≠do do processo (Q)
)

# Aplicar filtro de Kalman
state_means, _ = kf.filter(y_observed)

# Plot resultados
plt.plot(t, y_true, label='Sinal verdadeiro')
plt.plot(t, y_observed, label='Sinal com ru√≠do')
plt.plot(t, state_means, label='Filtro de Kalman')
plt.legend()
plt.show()

```
O gr√°fico demonstra como o filtro de Kalman consegue suavizar o ru√≠do e estimar o sinal verdadeiro, mostrando como o ru√≠do pode ser modelado e mitigado.
<!-- An√°lise de Res√≠duos: Avaliar se o filtro de Kalman est√° suavizando o ru√≠do adequadamente sem distorcer os outros componentes. -->
>üí° **Reflex√£o sobre a Irregularidade:** Embora n√£o possamos prever a irregularidade, model√°-la como um ru√≠do branco e usar t√©cnicas como o filtro de Kalman nos ajudam a reduzir seu impacto nas previs√µes.

**Corol√°rio 4.1:** O filtro de Kalman pode ser adaptado para modelar s√©ries temporais decompostas, onde o estado $x_t$ pode incluir os componentes de tend√™ncia, ciclo e sazonalidade. Nesse contexto, o ru√≠do do processo $w_t$ representaria a incerteza na evolu√ß√£o desses componentes, e o ru√≠do de medi√ß√£o $v_t$ representaria a irregularidade ou erro na observa√ß√£o da s√©rietemporal. O modelo de espa√ßo de estados, portanto, oferece uma estrutura flex√≠vel para lidar com essas complexidades inerentes aos dados de s√©ries temporais.

### Formula√ß√£o do Modelo de Espa√ßo de Estados

Um modelo de espa√ßo de estados √© definido por duas equa√ß√µes principais: a equa√ß√£o de estado e a equa√ß√£o de observa√ß√£o. A equa√ß√£o de estado descreve como o estado do sistema evolui ao longo do tempo, enquanto a equa√ß√£o de observa√ß√£o relaciona o estado do sistema com as observa√ß√µes que podemos fazer.

A equa√ß√£o de estado geralmente assume a forma:

$$
\mathbf{x}_{t+1} = \mathbf{F} \mathbf{x}_t + \mathbf{G} \mathbf{w}_t
$$

onde:
*   $\mathbf{x}_t$ √© o vetor de estado no instante *t*;
*   $\mathbf{F}$ √© a matriz de transi√ß√£o de estado, que descreve como o estado evolui de um instante para o pr√≥ximo;
*   $\mathbf{G}$ √© a matriz de controle de ru√≠do, que afeta como o ru√≠do de processo $\mathbf{w}_t$ afeta o estado;
*   $\mathbf{w}_t$ √© o ru√≠do de processo, que captura incertezas ou perturba√ß√µes no sistema. Assume-se que $\mathbf{w}_t$ segue uma distribui√ß√£o normal com m√©dia zero e matriz de covari√¢ncia $\mathbf{Q}$.

A equa√ß√£o de observa√ß√£o √© dada por:

$$
\mathbf{y}_t = \mathbf{H} \mathbf{x}_t + \mathbf{v}_t
$$

onde:
*   $\mathbf{y}_t$ √© o vetor de observa√ß√£o no instante *t*;
*   $\mathbf{H}$ √© a matriz de observa√ß√£o, que mapeia o estado para as observa√ß√µes;
*   $\mathbf{v}_t$ √© o ru√≠do de observa√ß√£o, que captura erros de medi√ß√£o ou incertezas nas observa√ß√µes. Assume-se que $\mathbf{v}_t$ segue uma distribui√ß√£o normal com m√©dia zero e matriz de covari√¢ncia $\mathbf{R}$.

### O Filtro de Kalman

O filtro de Kalman √© um algoritmo recursivo que estima o estado de um sistema din√¢mico a partir de uma s√©rie de medi√ß√µes ruidosas. Ele opera em dois passos: previs√£o e atualiza√ß√£o.

*   **Previs√£o:** Usa a equa√ß√£o de estado para prever o estado e a sua incerteza (covari√¢ncia) no instante seguinte, com base na estimativa anterior.
*   **Atualiza√ß√£o:** Usa a nova medi√ß√£o para ajustar a previs√£o e obter uma estimativa mais precisa do estado atual.

#### Passo de Previs√£o
1.  **Estado previsto:**
    $$
    \hat{\mathbf{x}}_{t|t-1} = \mathbf{F} \hat{\mathbf{x}}_{t-1|t-1}
    $$
    onde $\hat{\mathbf{x}}_{t|t-1}$ √© o estado previsto no instante *t* com base nas informa√ß√µes at√© *t-1*, e $\hat{\mathbf{x}}_{t-1|t-1}$ √© o estado estimado no instante *t-1*.

2.  **Covari√¢ncia do estado prevista:**
    $$
    \mathbf{P}_{t|t-1} = \mathbf{F} \mathbf{P}_{t-1|t-1} \mathbf{F}^T + \mathbf{G} \mathbf{Q} \mathbf{G}^T
    $$
    onde $\mathbf{P}_{t|t-1}$ √© a covari√¢ncia do estado prevista no instante *t*, e $\mathbf{P}_{t-1|t-1}$ √© a covari√¢ncia estimada no instante *t-1*.

#### Passo de Atualiza√ß√£o
1.  **Ganho de Kalman:**
    $$
    \mathbf{K}_t = \mathbf{P}_{t|t-1} \mathbf{H}^T (\mathbf{H} \mathbf{P}_{t|t-1} \mathbf{H}^T + \mathbf{R})^{-1}
    $$
    O ganho de Kalman $\mathbf{K}_t$ pondera a import√¢ncia da medi√ß√£o em rela√ß√£o √† previs√£o.

2.  **Estado atualizado:**
    $$
    \hat{\mathbf{x}}_{t|t} = \hat{\mathbf{x}}_{t|t-1} + \mathbf{K}_t (\mathbf{y}_t - \mathbf{H} \hat{\mathbf{x}}_{t|t-1})
    $$
    O estado atualizado $\hat{\mathbf{x}}_{t|t}$ √© uma combina√ß√£o da previs√£o e da medi√ß√£o, ponderada pelo ganho de Kalman.

3.  **Covari√¢ncia do estado atualizada:**
    $$
    \mathbf{P}_{t|t} = (\mathbf{I} - \mathbf{K}_t \mathbf{H}) \mathbf{P}_{t|t-1}
    $$
    A covari√¢ncia do estado atualizada $\mathbf{P}_{t|t}$ reflete a redu√ß√£o da incerteza ap√≥s a incorpora√ß√£o da medi√ß√£o.

### Aplica√ß√£o em S√©ries Temporais

O filtro de Kalman √© particularmente √∫til para lidar com s√©ries temporais que exibem comportamento din√¢mico, incluindo tend√™ncias, sazonalidades e ru√≠do. A flexibilidade do modelo de espa√ßo de estados permite que sejam adaptados a v√°rias estruturas de s√©ries temporais. Por exemplo, para modelar uma s√©rie temporal com tend√™ncia linear, podemos definir o vetor de estado como:

$$
\mathbf{x}_t = \begin{bmatrix} \text{n√≠vel}_t \\ \text{tend√™ncia}_t \end{bmatrix}
$$

E as matrizes $\mathbf{F}$, $\mathbf{G}$, e $\mathbf{H}$ como:
$$
\mathbf{F} = \begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}, \quad \mathbf{G} = \begin{bmatrix} 1 \\ 1 \end{bmatrix}, \quad \mathbf{H} = \begin{bmatrix} 1 & 0 \end{bmatrix}
$$

Nesse cen√°rio, o estado evolui com um n√≠vel que se desloca com a tend√™ncia, e a tend√™ncia varia com ru√≠do. A observa√ß√£o corresponde ao n√≠vel da s√©rie temporal.

O filtro de Kalman ent√£o iterativamente estima o n√≠vel e a tend√™ncia da s√©rie temporal, usando as medi√ß√µes observadas. Este √© apenas um exemplo, e modelos mais complexos podem ser definidos para capturar outras caracter√≠sticas, como sazonalidade e efeitos de covari√°veis.
<!-- END -->
