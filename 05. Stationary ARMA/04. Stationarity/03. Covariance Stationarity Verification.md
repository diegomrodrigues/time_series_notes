## T√≠tulo Conciso
Avalia√ß√£o Computacional da Covariance-Stationarity

### Introdu√ß√£o
Dando seguimento √† discuss√£o te√≥rica sobre covariance-stationarity apresentada anteriormente, este cap√≠tulo detalha os algoritmos e t√©cnicas computacionais utilizados para verificar se uma dada s√©rie temporal satisfaz as condi√ß√µes de estacionaridade [^45]. A verifica√ß√£o da covariance-stationarity √© crucial para a sele√ß√£o de modelos de s√©ries temporais apropriados e para garantir previs√µes confi√°veis [^45]. Este cap√≠tulo abordar√° testes estat√≠sticos e procedimentos pr√°ticos para avaliar a invari√¢ncia temporal da m√©dia e das autocovari√¢ncias.

### Conceitos Fundamentais
A avalia√ß√£o da covariance-stationarity em uma s√©rie temporal envolve a verifica√ß√£o de se a m√©dia ($\mu_t$) e as autocovari√¢ncias ($\gamma_{jt}$) s√£o independentes do tempo $t$ [^45]. Na pr√°tica, isso √© feito atrav√©s de testes estat√≠sticos de invari√¢ncia temporal e da an√°lise visual dos dados.

#### 1. Testes para Invari√¢ncia da M√©dia
A invari√¢ncia da m√©dia pode ser avaliada atrav√©s de testes de hip√≥teses que verificam se a m√©dia da s√©rie temporal permanece constante ao longo do tempo. Alguns testes comuns incluem:

*   **Teste t de Student:** Usado para comparar as m√©dias de duas amostras independentes. Em s√©ries temporais, pode ser aplicado para comparar as m√©dias de diferentes janelas de tempo da s√©rie.
*   **Teste de An√°lise de Vari√¢ncia (ANOVA):** Usado para comparar as m√©dias de mais de duas amostras. Em s√©ries temporais, pode ser aplicado para comparar as m√©dias de m√∫ltiplas janelas de tempo da s√©rie.
*   **Teste de Bartlett:** Usado para testar a homogeneidade das vari√¢ncias de diferentes amostras. Em s√©ries temporais, pode ser aplicado em conjunto com o teste ANOVA para verificar se as vari√¢ncias das janelas de tempo s√£o semelhantes.

No entanto, √© crucial reconhecer as limita√ß√µes desses testes. Eles s√£o sens√≠veis √† escolha das janelas de tempo e podem n√£o ser adequados para s√©ries temporais com depend√™ncia serial forte.

**Exemplo:** Teste de Hip√≥teses para M√©dia Constante
Suponha que temos uma s√©rie temporal de retornos di√°rios de uma a√ß√£o durante um per√≠odo de 5 anos (1250 dias). Queremos testar se a m√©dia dos retornos √© constante durante esse per√≠odo. Podemos dividir a s√©rie em cinco janelas de tempo de um ano cada (250 dias) e realizar um teste ANOVA para comparar as m√©dias dessas janelas.

1.  **Hip√≥tese Nula ($H_0$):** As m√©dias dos retornos em todas as janelas de tempo s√£o iguais.

2.  **Hip√≥tese Alternativa ($H_1$):** Pelo menos uma m√©dia √© diferente das outras.

Utilizando o teste ANOVA, calculamos a estat√≠stica F e o valor-p associado. Se o valor-p for menor que um n√≠vel de signific√¢ncia predefinido (e.g., 0.05), rejeitamos a hip√≥tese nula, indicando que h√° evid√™ncias de que a m√©dia dos retornos n√£o √© constante ao longo do tempo.
```python
import numpy as np
import scipy.stats as stats

# Simula√ß√£o de dados (retornos di√°rios)
np.random.seed(42)
T = 1250  # 5 anos de dados
retornos = np.random.normal(0.001, 0.01, T)  # m√©dia di√°ria 0.1%, desvio padr√£o 1%

# Dividir em janelas de tempo (1 ano cada)
janelas = np.split(retornos, 5) # split em 5 janelas

# Realizar o teste ANOVA
F, p = stats.f_oneway(*janelas)

print(f"Estat√≠stica F: {F:.2f}")
print(f"Valor-p: {p:.3f}")

alpha = 0.05
if p < alpha:
    print("Rejeitamos a hip√≥tese nula: h√° evid√™ncias de que a m√©dia n√£o √© constante.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° evid√™ncias suficientes para afirmar que a m√©dia n√£o √© constante.")
```
Para complementar a an√°lise de invari√¢ncia da m√©dia, podemos tamb√©m considerar testes n√£o-param√©tricos que s√£o menos sens√≠veis a distribui√ß√µes n√£o-normais dos dados.

*   **Teste de Kruskal-Wallis:** Uma alternativa n√£o-param√©trica ao ANOVA, que testa se as medianas de duas ou mais amostras independentes s√£o iguais. Este teste √© √∫til quando os dados n√£o seguem uma distribui√ß√£o normal ou quando os tamanhos das amostras s√£o pequenos.

**Exemplo:** Aplica√ß√£o do Teste de Kruskal-Wallis

Seguindo o exemplo anterior dos retornos di√°rios de uma a√ß√£o, podemos aplicar o teste de Kruskal-Wallis para verificar a invari√¢ncia da mediana dos retornos nas diferentes janelas de tempo.

1.  **Hip√≥tese Nula ($H_0$):** As medianas dos retornos em todas as janelas de tempo s√£o iguais.

2.  **Hip√≥tese Alternativa ($H_1$):** Pelo menos uma mediana √© diferente das outras.

```python
import numpy as np
import scipy.stats as stats

# Simula√ß√£o de dados (retornos di√°rios)
np.random.seed(42)
T = 1250  # 5 anos de dados
retornos = np.random.normal(0.001, 0.01, T)  # m√©dia di√°ria 0.1%, desvio padr√£o 1%

# Dividir em janelas de tempo (1 ano cada)
janelas = np.split(retornos, 5) # split em 5 janelas

# Realizar o teste de Kruskal-Wallis
H, p = stats.kruskal(*janelas)

print(f"Estat√≠stica H: {H:.2f}")
print(f"Valor-p: {p:.3f}")

alpha = 0.05
if p < alpha:
    print("Rejeitamos a hip√≥tese nula: h√° evid√™ncias de que a mediana n√£o √© constante.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° evid√™ncias suficientes para afirmar que a mediana n√£o √© constante.")
```

Para cen√°rios onde h√° suspeita de mudan√ßas graduais na m√©dia ao longo do tempo, o *teste de Mood-Brown*, tamb√©m conhecido como *teste da mediana*, pode ser empregado. Este teste verifica se as medianas de duas ou mais amostras s√£o iguais, sendo menos sens√≠vel a outliers do que testes baseados na m√©dia.

*   **Teste de Mood-Brown:** Este teste √© uma alternativa n√£o param√©trica √∫til quando se suspeita de altera√ß√µes graduais na m√©dia, pois compara as medianas das diferentes janelas de tempo.

**Exemplo:** Aplica√ß√£o do Teste de Mood-Brown

Adaptando o exemplo anterior, podemos aplicar o teste de Mood-Brown para verificar se a mediana dos retornos se mant√©m constante ao longo do tempo, especialmente se suspeitarmos de uma mudan√ßa gradual nos retornos.

1.  **Hip√≥tese Nula ($H_0$):** As medianas dos retornos em todas as janelas de tempo s√£o iguais.

2.  **Hip√≥tese Alternativa ($H_1$):** Pelo menos uma mediana √© diferente das outras.

```python
import numpy as np
import scipy.stats as stats

# Simula√ß√£o de dados (retornos di√°rios)
np.random.seed(42)
T = 1250  # 5 anos de dados
retornos = np.random.normal(0.001, 0.01, T)  # m√©dia di√°ria 0.1%, desvio padr√£o 1%

# Introduzir uma mudan√ßa gradual na m√©dia
for i in range(T):
    retornos[i] += 0.00001 * i  # Pequeno aumento gradual na m√©dia

# Dividir em janelas de tempo (1 ano cada)
janelas = np.split(retornos, 5)

# Realizar o teste de Mood-Brown (usando a fun√ß√£o median_test)
stat, p, med, expected = stats.median_test(*janelas)

print(f"Estat√≠stica de teste: {stat:.2f}")
print(f"Valor-p: {p:.3f}")

alpha = 0.05
if p < alpha:
    print("Rejeitamos a hip√≥tese nula: h√° evid√™ncias de que a mediana n√£o √© constante.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° evid√™ncias suficientes para afirmar que a mediana n√£o √© constante.")
```

> üí° **Exemplo Num√©rico:** Suponha que temos dados de temperatura m√©dia mensal em uma cidade por 10 anos. Dividimos os dados em duas janelas de tempo: os primeiros 5 anos e os √∫ltimos 5 anos. Calculamos a m√©dia de temperatura para cada janela. Se a m√©dia dos primeiros 5 anos for 25¬∞C e a m√©dia dos √∫ltimos 5 anos for 27¬∞C, podemos usar um teste t de Student para verificar se essa diferen√ßa √© estatisticamente significativa. A hip√≥tese nula seria que as m√©dias s√£o iguais. Se o valor-p do teste t for menor que 0.05, rejeitar√≠amos a hip√≥tese nula e concluir√≠amos que h√° evid√™ncias de que a m√©dia da temperatura mudou ao longo do tempo.

#### 2. Testes para Invari√¢ncia da Autocovari√¢ncia
A invari√¢ncia da autocovari√¢ncia √© mais complexa de avaliar. Alguns m√©todos incluem:

*   **An√°lise Visual do Correlograma:** O correlograma √© um gr√°fico que mostra as autocorrela√ß√µes da s√©rie temporal em diferentes lags. Para uma s√©rie covariance-stationary, o correlograma deve decair rapidamente para zero √† medida que o lag aumenta [^49]. Al√©m disso, a estrutura do correlograma n√£o deve mudar significativamente ao longo do tempo.
*   **Teste de Dickey-Fuller Aumentado (ADF):** Este teste √© usado para verificar a presen√ßa de raiz unit√°ria em uma s√©rie temporal. Uma raiz unit√°ria indica n√£o estacionariedade. No entanto, o teste ADF √© projetado para detectar apenas um tipo espec√≠fico de n√£o estacionariedade (raiz unit√°ria) e pode n√£o ser adequado para outros tipos.
*   **Teste de Kwiatkowski-Phillips-Schmidt-Shin (KPSS):** Este teste testa a hip√≥tese nula de que a s√©rie temporal √© estacion√°ria em torno de uma m√©dia ou tend√™ncia determin√≠stica. Ao contr√°rio do teste ADF, o teste KPSS favorece a estacionaridade na hip√≥tese nula.
*   **Teste de Engle-Granger:** Pode ser usado para verificar a cointegra√ß√£o entre duas ou mais s√©ries temporais. Se as s√©ries s√£o cointegradas, uma combina√ß√£o linear delas √© estacion√°ria.

√â importante notar que a rejei√ß√£o da hip√≥tese nula de n√£o estacionariedade em um teste (como ADF) n√£o garante que a s√©rie seja covariance-stationary. Da mesma forma, a falha em rejeitar a hip√≥tese nula de estacionaridade em um teste (como KPSS) n√£o prova a estacionaridade.

**Exemplo:** Teste de Hip√≥teses para Raiz Unit√°ria (Teste ADF)
Suponha que temos uma s√©rie temporal de pre√ßos mensais de petr√≥leo bruto durante um per√≠odo de 20 anos (240 meses). Queremos testar se a s√©rie √© estacion√°ria. Podemos aplicar o teste ADF:

1.  **Hip√≥tese Nula ($H_0$):** A s√©rie temporal tem uma raiz unit√°ria (n√£o √© estacion√°ria).

2.  **Hip√≥tese Alternativa ($H_1$):** A s√©rie temporal n√£o tem uma raiz unit√°ria (√© estacion√°ria).

```python
from statsmodels.tsa.stattools import adfuller
import pandas as pd
import numpy as np

# Simula√ß√£o de dados (pre√ßos mensais de petr√≥leo)
np.random.seed(42)
T = 240
# Simula√ß√£o de um processo n√£o estacion√°rio (passeio aleat√≥rio com drift)
drift = 0.1
sigma = 2
precos_petroleo = np.cumsum(np.random.normal(drift, sigma, T))

# Realizar o teste ADF
result = adfuller(precos_petroleo)

print('Estat√≠stica ADF: %f' % result[0])
print('Valor-p: %f' % result[1])
print('Valores cr√≠ticos:')
for key, value in result[4].items():
	print('\t%s: %.3f' % (key, value))

alpha = 0.05
if result[1] < alpha:
    print("Rejeitamos a hip√≥tese nula: h√° evid√™ncias de que a s√©rie √© estacion√°ria.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° evid√™ncias suficientes para afirmar que a s√©rie √© estacion√°ria.")
```

> üí° **Exemplo Num√©rico:** Imagine que voc√™ plotou o correlograma de uma s√©rie temporal e observou que as autocorrela√ß√µes decaem muito lentamente e permanecem significativamente diferentes de zero mesmo em lags altos (e.g., lag 20). Isso sugere que a s√©rie tem uma mem√≥ria longa e pode n√£o ser covariance-stationary. Por outro lado, se o correlograma decair rapidamente para zero ap√≥s alguns lags, isso √© um indicativo de estacionaridade.

**Correla√ß√£o Cruzada:**

Em algumas situa√ß√µes, pode ser √∫til examinar a correla√ß√£o cruzada entre diferentes segmentos da s√©rie temporal. Se a estrutura da correla√ß√£o cruzada mudar significativamente com o tempo, isso pode indicar uma viola√ß√£o da estacionaridade.
  * **Procedimento:** Divida a s√©rie temporal em janelas de tempo sobrepostas ou n√£o.
  * **C√°lculo:** Calcule a correla√ß√£o cruzada entre pares de janelas.
  * **An√°lise:** Compare os padr√µes de correla√ß√£o cruzada entre diferentes pares de janelas. Mudan√ßas significativas podem indicar n√£o estacionaridade.

> üí° **Exemplo Num√©rico:** Considere uma s√©rie temporal de vendas mensais de um produto em uma loja de departamento. Divida a s√©rie em 3 janelas de tempo: (1) Janeiro 2021 - Dezembro 2021, (2) Janeiro 2022 - Dezembro 2022, (3) Janeiro 2023 - Dezembro 2023. Calcule a correla√ß√£o cruzada entre a s√©rie de vendas da janela (1) e a janela (2), e tamb√©m entre a janela (2) e a janela (3). Se o padr√£o de correla√ß√£o cruzada (e.g., lags significativos) mudar drasticamente de um par de janelas para outro, isso sugere que a rela√ß√£o temporal dentro da s√©rie n√£o √© consistente ao longo do tempo, indicando n√£o estacionaridade.
```python
import numpy as np
import pandas as pd
import statsmodels.tsa.api as smt
import matplotlib.pyplot as plt

# Simula√ß√£o de uma s√©rie temporal com mudan√ßa estrutural
np.random.seed(42)
T = 36  # 3 anos de dados mensais
meses = pd.date_range('2021-01', periods=T, freq='M')
df = pd.DataFrame({'Meses': meses})

# Primeiro ano: Crescimento linear + ru√≠do
df['Vendas'] = np.linspace(100, 120, 12) + np.random.normal(0, 5, 12)

# Segundo ano: Queda acentuada + recupera√ß√£o
df['Vendas'][12:24] = np.linspace(120, 80, 12) + np.random.normal(0, 5, 12)

# Terceiro ano: Sazonalidade + tend√™ncia
sazonalidade = 10 * np.sin(2 * np.pi * np.arange(12) / 12)
df['Vendas'][24:] = np.linspace(80, 130, 12) + sazonalidade + np.random.normal(0, 5, 12)

# Definir janelas de tempo
janela1 = df['Vendas'][:12]
janela2 = df['Vendas'][12:24]
janela3 = df['Vendas'][24:]

# Fun√ß√£o para calcular a correla√ß√£o cruzada
def crosscorr(x, y, lag=0):
    x = pd.Series(x)
    y = pd.Series(y)
    return x.corr(y.shift(lag))

# Definir lags para an√°lise de correla√ß√£o cruzada
lags = range(-5, 6)  # Lags de -5 a 5

# Calcular correla√ß√µes cruzadas para cada par de janelas
crosscorr12 = [crosscorr(janela1, janela2, lag) for lag in lags]
crosscorr23 = [crosscorr(janela2, janela3, lag) for lag in lags]

# Plotar as correla√ß√µes cruzadas
plt.figure(figsize=(12, 6))
plt.plot(lags, crosscorr12, marker='o', label='Janela 1 vs Janela 2')
plt.plot(lags, crosscorr23, marker='x', label='Janela 2 vs Janela 3')
plt.title('Correla√ß√£o Cruzada entre Janelas de Tempo')
plt.xlabel('Lag')
plt.ylabel('Correla√ß√£o')
plt.legend()
plt.grid(True)
plt.show()
```

**Interpreta√ß√£o:**  O gr√°fico de correla√ß√£o cruzada mostrar√° padr√µes distintos para os dois pares de janelas. Por exemplo, a correla√ß√£o no lag 0 pode ser alta para a janela 1 vs janela 2, mas baixa para a janela 2 vs janela 3. Al√©m disso, os lags com correla√ß√µes significativas podem ser diferentes para os dois pares. Essas mudan√ßas nos padr√µes de correla√ß√£o cruzada indicam que a rela√ß√£o temporal dentro da s√©rie n√£o √© consistente ao longo do tempo, sugerindo n√£o estacionaridade.

Para complementar a an√°lise da autocovari√¢ncia, podemos tamb√©m considerar a estima√ß√£o e compara√ß√£o dos espectros de pot√™ncia em diferentes janelas de tempo.

*   **An√°lise Espectral em Janelas Deslizantes:** Divide-se a s√©rie temporal em janelas de tempo (possivelmente sobrepostas) e calcula-se o espectro de pot√™ncia para cada janela. A compara√ß√£o dos espectros de pot√™ncia entre diferentes janelas pode revelar mudan√ßas na estrutura de frequ√™ncias da s√©rie, indicando n√£o estacionaridade.

**Procedimento:**

1.  **Definir Janelas:** Divida a s√©rie temporal em janelas de tempo sobrepostas ou n√£o.
2.  **Estimar Espectro de Pot√™ncia:** Para cada janela, estime o espectro de pot√™ncia utilizando m√©todos como a Transformada de Fourier Discreta (DFT) ou o periodograma.
3.  **Comparar Espectros:** Compare os espectros de pot√™ncia entre diferentes janelas. Mudan√ßas significativas nas frequ√™ncias dominantes ou na forma geral do espectro podem indicar n√£o estacionaridade.

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.fft import fft

# Simula√ß√£o de uma s√©rie temporal com mudan√ßa na estrutura de frequ√™ncias
np.random.seed(42)
T = 500  # Tamanho da s√©rie temporal
t = np.arange(T)

# Primeira metade: Sinal com frequ√™ncia baixa
sinal1 = np.sin(2 * np.pi * 0.01 * t[:T//2]) + np.random.normal(0, 0.5, T//2)

# Segunda metade: Sinal com frequ√™ncia alta
sinal2 = np.sin(2 * np.pi * 0.05 * t[T//2:]) + np.random.normal(0, 0.5, T//2)

# Concatenar os sinais
serie_temporal = np.concatenate([sinal1, sinal2])

# Definir tamanho da janela
tamanho_janela = 100

# Calcular o espectro de pot√™ncia para a primeira janela
janela1 = serie_temporal[:tamanho_janela]
fft_janela1 = fft(janela1)
frequencias1 = np.fft.fftfreq(tamanho_janela)
espectro_potencia1 = np.abs(fft_janela1)**2

# Calcular o espectro de pot√™ncia para a segunda janela (deslocada)
janela2 = serie_temporal[T//2:T//2+tamanho_janela]
fft_janela2 = fft(janela2)
frequencias2 = np.fft.fftfreq(tamanho_janela)
espectro_potencia2 = np.abs(fft_janela2)**2

# Plotar os espectros de pot√™ncia
plt.figure(figsize=(12, 6))
plt.plot(frequencias1[:tamanho_janela//2], espectro_potencia1[:tamanho_janela//2], label='Primeira Janela')
plt.plot(frequencias2[:tamanho_janela//2], espectro_potencia2[:tamanho_janela//2], label='Segunda Janela')
plt.title('Espectro de Pot√™ncia em Diferentes Janelas')
plt.xlabel('Frequ√™ncia')
plt.ylabel('Pot√™ncia')
plt.legend()
plt.grid(True)
plt.show()
```

**Interpreta√ß√£o:** Os espectros de pot√™ncia das duas janelas mostrar√£o picos em frequ√™ncias diferentes. A primeira janela (sinal de baixa frequ√™ncia) ter√° um pico em frequ√™ncias mais baixas, enquanto a segunda janela (sinal de alta frequ√™ncia) ter√° um pico em frequ√™ncias mais altas. Essa diferen√ßa nos espectros de pot√™ncia indica que a estrutura de frequ√™ncias da s√©rie temporal mudou ao longo do tempo, sugerindo n√£o estacionaridade.

Al√©m dos testes j√° mencionados, o *teste de Ljung-Box* pode ser aplicado aos res√≠duos de um modelo ajustado √† s√©rie temporal para verificar se h√° autocorrela√ß√£o residual.

*   **Teste de Ljung-Box:** Aplica-se aos res√≠duos de um modelo para verificar a presen√ßa de autocorrela√ß√£o serial, o que pode indicar n√£o estacionaridade.

**Procedimento:**
1. **Ajustar um Modelo:** Ajustar um modelo adequado √† s√©rie temporal.
2. **Calcular Res√≠duos:** Calcular os res√≠duos do modelo ajustado.
3. **Aplicar Teste de Ljung-Box:** Aplicar o teste de Ljung-Box aos res√≠duos para verificar se h√° autocorrela√ß√£o serial.

```python
import numpy as np
import pandas as pd
import statsmodels.api as sm
from statsmodels.stats.diagnostic import acorr_ljungbox
import matplotlib.pyplot as plt

# Simula√ß√£o de dados (s√©rie temporal AR(1) n√£o estacion√°ria)
np.random.seed(42)
T = 200
phi = 0.95  # Coeficiente AR pr√≥ximo de 1 (n√£o estacion√°rio)
erros = np.random.normal(0, 1, T)
serie_temporal = np.zeros(T)
serie_temporal[0] = erros[0]
for t in range(1, T):
    serie_temporal[t] = phi * serie_temporal[t-1] + erros[t]

# Ajustar um modelo AR(1) √† s√©rie temporal
modelo_ar = sm.tsa.ARIMA(serie_temporal, order=(1, 0, 0)) # Modelo AR(1)
resultado_ar = modelo_ar.fit()

# Calcular os res√≠duos
residuos = resultado_ar.resid

# Aplicar o teste de Ljung-Box aos res√≠duos
lbvalue, pvalue = acorr_ljungbox(residuos, lags=[10]) # Testar at√© o lag 10

print(f"Estat√≠stica de Ljung-Box: {lbvalue[0]:.2f}")
print(f"Valor-p: {pvalue[0]:.3f}")

alpha = 0.05
if pvalue[0] < alpha:
    print("Rejeitamos a hip√≥tese nula: h√° evid√™ncias de autocorrela√ß√£o nos res√≠duos.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° evid√™ncias de autocorrela√ß√£o nos res√≠duos.")

# Plotar os res√≠duos
plt.figure(figsize=(12, 6))
plt.plot(residuos, label='Res√≠duos do Modelo AR(1)')
plt.title('Res√≠duos do Modelo AR(1)')
plt.legend()
plt.grid(True)
plt.show()
```

#### 3. An√°lise Visual
A inspe√ß√£o visual da s√©rie temporal pode fornecer insights valiosos sobre sua estacionaridade. Alguns padr√µes a serem observados incluem:
*   **Tend√™ncia:** Uma tend√™ncia crescente ou decrescente ao longo do tempo indica n√£o estacionaridade na m√©dia.
*   **Sazonalidade:** Padr√µes que se repetem em intervalos regulares (e.g., anualmente, mensalmente) indicam n√£o estacionaridade.
*   **Varia√ß√£o da Vari√¢ncia:** Se a variabilidade da s√©rie mudar significativamente ao longo do tempo, isso indica n√£o estacionaridade na vari√¢ncia.
*   **Mudan√ßas Abruptas:** Mudan√ßas abruptas no n√≠vel da s√©rie podem indicar n√£o estacionaridade.

√â importante combinar a an√°lise visual com testes estat√≠sticos para uma avalia√ß√£o mais robusta da covariance-stationarity.

> üí° **Exemplo Num√©rico:** Considere um gr√°fico de uma s√©rie temporal que representa o n√∫mero de passageiros em uma companhia a√©rea ao longo de v√°rios anos. Se voc√™ observar um aumento constante no n√∫mero de passageiros ao longo do tempo (tend√™ncia crescente), juntamente com picos regulares a cada ver√£o (sazonalidade), isso indica claramente que a s√©rie n√£o √© estacion√°ria. A tend√™ncia sugere que a m√©dia n√£o √© constante, e a sazonalidade indica padr√µes repetitivos que violam a condi√ß√£o de invari√¢ncia temporal.
> ```mermaid
>   graph LR
>       A[In√≠cio] --> B(Observar Tend√™ncia Crescente);
>       B --> C{Tend√™ncia Presente?};
>       C -- Sim --> D(N√£o Estacion√°rio na M√©dia);
>       C -- N√£o --> E(Observar Sazonalidade);
>       E --> F{Sazonalidade Presente?};
>       F -- Sim --> G(N√£o Estacion√°rio);
>       F -- N√£o --> H(Analisar Varia√ß√£o da Vari√¢ncia);
>       H --> I{Varia√ß√£o da Vari√¢ncia?};
>       I -- Sim --> J(N√£o Estacion√°rio na Vari√¢ncia);
>       I -- N√£o --> K(Realizar Testes Estat√≠sticos);
> ```

### T√©cnicas Computacionais
A implementa√ß√£o pr√°tica dos testes estat√≠sticos e da an√°lise visual requer o uso de bibliotecas de software especializadas. Algumas bibliotecas populares incluem:

*   **Statsmodels (Python):** Fornece implementa√ß√µes de diversos testes de estacionaridade, como ADF e KPSS [statsmodels].
*   **rpy2 (Python):** Permite a execu√ß√£o de c√≥digo R dentro do Python, possibilitando o uso de testes e fun√ß√µes estat√≠sticas dispon√≠veis no R que n√£o est√£o implementadas no Python.
*   **EViews:** Um software econom√©trico comercial com uma ampla gama de testes de estacionaridade e ferramentas de an√°lise de s√©ries temporais.

Al√©m dessas bibliotecas, o `scikit-learn` em Python pode ser utilizado para implementar modelos de aprendizado de m√°quina que podem auxiliar na detec√ß√£o de n√£o-estacionaridade atrav√©s da an√°lise de res√≠duos.

*   **An√°lise de Res√≠duos de Modelos:** Ajustar um modelo √† s√©rie temporal (e.g., um modelo de regress√£o linear) e analisar os res√≠duos. Se os res√≠duos exibirem padr√µes (tend√™ncia, sazonalidade, autocorrela√ß√£o), isso pode indicar que a s√©rie n√£o √© estacion√°ria e que o modelo n√£o capturou completamente a din√¢mica dos dados.

**Procedimento:**

1.  **Ajustar Modelo:** Ajustar um modelo apropriado √† s√©rie temporal (e.g., regress√£o linear com tend√™ncia, modelo sazonal).
2.  **Analisar Res√≠duos:** Calcular os res√≠duos (diferen√ßa entre os valores observados e os valores previstos pelo modelo).
3.  **Testar Estacionaridade dos Res√≠duos:** Aplicar testes de estacionaridade (e.g., ADF, KPSS) aos res√≠duos. Se os res√≠duos n√£o forem estacion√°rios, isso indica que a s√©rie original tamb√©m n√£o √© estacion√°ria.

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from statsmodels.tsa.stattools import adfuller

# Simula√ß√£o de uma s√©rie temporal com tend√™ncia
np.random.seed(42)
T = 200
t = np.arange(T)
serie_temporal = 50 + 2 * t + np.random.normal(0, 10, T)  # Tend√™ncia linear + ru√≠do

# Ajustar um modelo de regress√£o linear
modelo = LinearRegression()
modelo.fit(t.reshape(-1, 1), serie_temporal)
previsoes = modelo.predict(t.reshape(-1, 1))

# Calcular os res√≠duos
residuos = serie_temporal - previsoes

# Testar a estacionaridade dos res√≠duos (ADF)
result = adfuller(residuos)
print('Estat√≠stica ADF: %f' % result[0])
print('Valor-p: %f' % result[1])
print('Valores cr√≠ticos:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

alpha = 0.05
if result[1] < alpha:
    print("Rejeitamos a hip√≥tese nula: os res√≠duos s√£o estacion√°rios.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° evid√™ncias suficientes para afirmar que os res√≠duos s√£o estacion√°rios.")

# Plotar a s√©rie temporal e os res√≠duos
plt.figure(figsize=(12, 6))
plt.plot(serie_temporal, label='S√©rie Temporal')
plt.plot(previsoes, color='red', label='Regress√£o Linear')
plt.title('S√©rie Temporal com Tend√™ncia e Regress√£o Linear')
plt.legend()
plt.grid(True)

plt.figure(figsize=(12, 6))
plt.plot(residuos, label='Res√≠duos')
plt.title('Res√≠duos da Regress√£o Linear')
plt.legend()
plt.grid(True)
plt.show()
```

**Interpreta√ß√£o:** Se a s√©rie temporal tiver uma tend√™ncia (como no exemplo), o modelo de regress√£o linear capturar√° parte dessa tend√™ncia. No entanto, se os res√≠duos ainda exibirem padr√µes (e.g., autocorrela√ß√£o), e o teste ADF indicar que os res√≠duos n√£o s√£o estacion√°rios, isso sugere que a s√©rie original n√£o √© estacion√°ria e que um modelo mais complexo pode ser necess√°rio.

Para detectar mudan√ßas na vari√¢ncia ao longo do tempo, podemos empregar o *teste de Levene*.

*   **Teste de Levene:** Avalia a igualdade das vari√¢ncias entre diferentes subconjuntos da s√©rie temporal.

**Procedimento:**
1. **Dividir a S√©rie:** Dividir a s√©rie temporal em janelas de tempo.
2. **Aplicar o Teste de Levene:** Aplicar o teste de Levene para verificar se as vari√¢ncias das diferentes janelas s√£o estatisticamente iguais.

```python
import numpy as np
import scipy.stats as stats

# Simula√ß√£o de dados (s√©rie temporal com mudan√ßa na vari√¢ncia)
np.random.seed(42)
T = 200
serie_temporal = np.random.normal(0, 1, T) # Vari√¢ncia inicial = 1

# Aumentar a vari√¢ncia na segunda metade da s√©rie
serie_temporal[T//2:] = np.random.normal(0, 5, T//2) # Vari√¢ncia final = 25

# Dividir a s√©rie em duas janelas
janela1 = serie_temporal[:T//2]
janela2 = serie_temporal[T//2:]

# Aplicar o teste de Levene
stat, p = stats.levene(janela1, janela2)

print(f"Estat√≠stica de Levene: {stat:.2f}")
print(f"Valor-p: {p:.3f}")

alpha = 0.05
if p < alpha:
    print("Rejeitamos a hip√≥tese nula: h√° evid√™ncias de que as vari√¢ncias s√£o diferentes.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° evid√™ncias suficientes para afirmar que as vari√¢ncias s√£o diferentes.")
```
> üí° **Exemplo Num√©rico:** Suponha que, ap√≥s ajustar um modelo ARIMA a uma s√©rie temporal, voc√™ calcula os res√≠duos. Ao plotar o correlograma dos res√≠duos, voc√™ observa que as autocorrela√ß√µes s√£o significativamente diferentes de zero em v√°rios lags. Al√©m disso, o teste de Ljung-Box aplicado aos res√≠duos resulta em um valor-p menor que 0.05. Isso sugere que h√° autocorrela√ß√£o serial nos res√≠duos, indicando que o modelo ARIMA n√£o capturou completamente a depend√™ncia temporal na s√©rie original, e que a s√©rie pode n√£o ser estacion√°ria.

### Conclus√£o
A avalia√ß√£o da covariance-stationarity √© um passo crucial na an√°lise de s√©ries temporais [^45]. A combina√ß√£o de testes estat√≠sticos, an√°lise visual e ferramentas computacionais permite uma avalia√ß√£o robusta da estacionaridade e orienta a sele√ß√£o de modelos apropriados [^45]. A escolha inadequada de modelos devido √† falta de verifica√ß√£o da estacionaridade pode levar a previs√µes imprecisas e conclus√µes err√¥neas.

### Refer√™ncias
[^45]: P√°g. 45, Chapter 3, Stationary ARMA Processes
[^49]: P√°g. 49, Chapter 3, Stationary ARMA Processes
[statsmodels]: Statsmodels: Econometric and Statistical Modeling with Python. Dispon√≠vel em: [https://www.statsmodels.org/stable/](https://www.statsmodels.org/stable/)
<!-- END -->