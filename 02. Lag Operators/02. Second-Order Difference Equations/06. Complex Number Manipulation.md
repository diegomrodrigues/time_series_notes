## A Manipula√ß√£o de N√∫meros Complexos em Equa√ß√µes de Diferen√ßa e Algoritmos de Solu√ß√£o

### Introdu√ß√£o
Este cap√≠tulo aborda um aspecto crucial na solu√ß√£o de equa√ß√µes de diferen√ßa de segunda ordem: a manipula√ß√£o de n√∫meros complexos quando as ra√≠zes caracter√≠sticas s√£o complexas conjugadas. Anteriormente, exploramos a import√¢ncia da fatora√ß√£o do polin√¥mio do operador de atraso e a estabilidade do sistema em fun√ß√£o das ra√≠zes caracter√≠sticas [^3, ^4]. No entanto, quando as ra√≠zes caracter√≠sticas s√£o complexas, a manipula√ß√£o de n√∫meros complexos requer aten√ß√£o especial para garantir resultados v√°lidos e precisos, evitando erros num√©ricos. Este cap√≠tulo explorar√° como os n√∫meros complexos surgem na solu√ß√£o de equa√ß√µes de diferen√ßa, as t√©cnicas para manipula√ß√£o computacional e as implica√ß√µes para a implementa√ß√£o de algoritmos de solu√ß√£o.

### O Surgimento de N√∫meros Complexos

N√∫meros complexos aparecem na solu√ß√£o de equa√ß√µes de diferen√ßa de segunda ordem quando o discriminante da equa√ß√£o quadr√°tica, $\phi_1^2 + 4\phi_2$, √© negativo. A equa√ß√£o caracter√≠stica associada a uma equa√ß√£o de diferen√ßa de segunda ordem $y_t = \phi_1 y_{t-1} + \phi_2 y_{t-2} + w_t$ √© dada por [^3]:

$$ \lambda^2 - \phi_1 \lambda - \phi_2 = 0 $$
As ra√≠zes dessa equa√ß√£o s√£o:
$$
\lambda_{1,2} = \frac{\phi_1 \pm \sqrt{\phi_1^2 + 4\phi_2}}{2}
$$
Quando $\phi_1^2 + 4\phi_2 < 0$, as ra√≠zes $\lambda_1$ e $\lambda_2$ s√£o complexas conjugadas, ou seja, podem ser escritas como $a + bi$ e $a - bi$, onde $a$ e $b$ s√£o n√∫meros reais e $i$ √© a unidade imagin√°ria ($i^2 = -1$).
As ra√≠zes complexas conjugadas indicam que a solu√ß√£o da equa√ß√£o de diferen√ßa apresentar√° um comportamento oscilat√≥rio, o que √© comum em muitos sistemas din√¢micos.
> üí° **Observa√ß√£o:** A forma como essas ra√≠zes complexas s√£o manipuladas em algoritmos num√©ricos √© crucial para obter resultados precisos e evitar erros de propaga√ß√£o que podem levar a solu√ß√µes inst√°veis.

#### Representa√ß√£o Polar de N√∫meros Complexos
Para facilitar a manipula√ß√£o de n√∫meros complexos, eles podem ser representados na forma polar:

$$z = r(\cos(\theta) + i\sin(\theta)) = re^{i\theta}$$

onde $r$ √© o m√≥dulo e $\theta$ √© o argumento do n√∫mero complexo. Na forma polar, o produto de dois n√∫meros complexos √©:
$$z_1 z_2 = r_1 r_2 e^{i(\theta_1 + \theta_2)}$$
Essa propriedade √© √∫til quando trabalhamos com pot√™ncias de n√∫meros complexos.

Para as ra√≠zes caracter√≠sticas complexas conjugadas $\lambda_1 = a+bi$ e $\lambda_2=a-bi$, o m√≥dulo √© dado por $r = \sqrt{a^2 + b^2}$, e o argumento por $\theta = \arctan(\frac{b}{a})$. As ra√≠zes podem ser expressas como:
$$ \lambda_1 = re^{i\theta} $$
$$ \lambda_2 = re^{-i\theta} $$

> üí° **Exemplo Num√©rico:**
> Considere a equa√ß√£o de diferen√ßa $y_t = 0.5y_{t-1} - 0.75y_{t-2} + w_t$. As ra√≠zes s√£o:
> $$ \lambda_{1,2} = \frac{0.5 \pm \sqrt{0.5^2 - 4(0.75)}}{2} = \frac{0.5 \pm \sqrt{0.25 - 3}}{2} = \frac{0.5 \pm \sqrt{-2.75}}{2} = 0.25 \pm i\frac{\sqrt{2.75}}{2} \approx 0.25 \pm 0.829i $$
> Aqui, $a = 0.25$ e $b = 0.829$. O m√≥dulo √© $r = \sqrt{0.25^2 + 0.829^2} \approx 0.866$ e o argumento √© $\theta = \arctan(\frac{0.829}{0.25}) \approx 1.286$ radianos. Assim, as ra√≠zes s√£o:
> $$ \lambda_1 \approx 0.866e^{1.286i} $$
> $$ \lambda_2 \approx 0.866e^{-1.286i} $$
>
> Usando a representa√ß√£o polar, podemos calcular, por exemplo, $\lambda_1^5$:
> $$ \lambda_1^5 \approx (0.866e^{1.286i})^5 \approx 0.866^5 e^{5 \times 1.286i} \approx 0.483 e^{6.43i} \approx 0.483 (\cos(6.43) + i\sin(6.43)) \approx 0.483 (-0.975 + 0.222i) \approx -0.471 + 0.107i $$
>
> Observe que, se tiv√©ssemos calculado $\lambda_1^5$ usando a forma retangular e as opera√ß√µes em ponto flutuante diretamente, os resultados poderiam ter erros de arredondamento maiores. Por isso, a forma polar facilita os c√°lculos.

**Proposi√ß√£o 1.1** Se as ra√≠zes caracter√≠sticas s√£o complexas conjugadas, ou seja,  $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$, a soma das pot√™ncias das ra√≠zes pode ser expressa usando a f√≥rmula de Euler como:
$$ \lambda_1^t + \lambda_2^t = 2r^t \cos(t\theta) $$

*Prova:*
I.  Dado que $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$, temos $\lambda_1^t = r^t e^{it\theta} = r^t (\cos(t\theta) + i\sin(t\theta))$ e $\lambda_2^t = r^t e^{-it\theta} = r^t (\cos(t\theta) - i\sin(t\theta))$
II. Somando as duas express√µes, obtemos
     $$ \lambda_1^t + \lambda_2^t = r^t (\cos(t\theta) + i\sin(t\theta)) + r^t (\cos(t\theta) - i\sin(t\theta)) $$
III. Simplificando, os termos imagin√°rios se cancelam e obtemos
     $$ \lambda_1^t + \lambda_2^t = 2r^t \cos(t\theta) $$
Portanto, se as ra√≠zes s√£o complexas, as solu√ß√µes da equa√ß√£o de diferen√ßas oscilar√£o, com uma magnitude que √© determinada pelo m√≥dulo das ra√≠zes e uma frequ√™ncia determinada pelo √¢ngulo. ‚ñ†

**Observa√ß√£o 1.2** A proposi√ß√£o 1.1 nos diz que quando as ra√≠zes s√£o complexas conjugadas, os componentes da solu√ß√£o da equa√ß√£o de diferen√ßas oscilam. O m√≥dulo da raiz determina a amplitude da oscila√ß√£o: se $|\lambda| < 1$ a amplitude decresce com o tempo. Se $|\lambda| = 1$ a amplitude permanece constante. Se $|\lambda| > 1$ a amplitude cresce. A frequ√™ncia da oscila√ß√£o √© determinada pelo argumento $\theta$.

**Proposi√ß√£o 1.3** Se as ra√≠zes caracter√≠sticas s√£o complexas conjugadas, ou seja, $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$, a diferen√ßa das pot√™ncias das ra√≠zes pode ser expressa usando a f√≥rmula de Euler como:
$$ \lambda_1^t - \lambda_2^t = 2i r^t \sin(t\theta) $$

*Prova:*
I. Dado que $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$, temos $\lambda_1^t = r^t e^{it\theta} = r^t (\cos(t\theta) + i\sin(t\theta))$ e $\lambda_2^t = r^t e^{-it\theta} = r^t (\cos(t\theta) - i\sin(t\theta))$
II. Subtraindo as duas express√µes, obtemos
     $$ \lambda_1^t - \lambda_2^t = r^t (\cos(t\theta) + i\sin(t\theta)) - r^t (\cos(t\theta) - i\sin(t\theta)) $$
III. Simplificando, os termos reais se cancelam e obtemos
     $$ \lambda_1^t - \lambda_2^t = 2i r^t \sin(t\theta) $$
Portanto, a diferen√ßa das pot√™ncias das ra√≠zes complexas conjugadas √© um n√∫mero imagin√°rio, cujo m√≥dulo tamb√©m √© determinado pelo m√≥dulo da raiz e uma frequ√™ncia determinada pelo argumento. ‚ñ†

**Proposi√ß√£o 1.4** Se $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$ s√£o ra√≠zes complexas conjugadas de um polin√¥mio caracter√≠stico de uma equa√ß√£o de diferen√ßas, ent√£o a soma $\lambda_1^t + \lambda_2^t$ √© sempre um n√∫mero real.
*Prova:*
I. Pela Proposi√ß√£o 1.1, sabemos que $\lambda_1^t + \lambda_2^t = 2r^t \cos(t\theta)$.
II. O resultado $2r^t \cos(t\theta)$ √© um n√∫mero real, pois $r$ √© o m√≥dulo da raiz, e $\cos(t\theta)$ √© uma fun√ß√£o trigonom√©trica que produz valores reais.
III. Portanto, a soma das pot√™ncias das ra√≠zes complexas conjugadas √© sempre um n√∫mero real.
‚ñ†
**Proposi√ß√£o 1.5** Se $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$ s√£o ra√≠zes complexas conjugadas de um polin√¥mio caracter√≠stico de uma equa√ß√£o de diferen√ßas, ent√£o a diferen√ßa $\lambda_1^t - \lambda_2^t$ √© sempre um n√∫mero imagin√°rio puro.
*Prova:*
I. Pela Proposi√ß√£o 1.3, sabemos que $\lambda_1^t - \lambda_2^t = 2i r^t \sin(t\theta)$.
II. O resultado $2i r^t \sin(t\theta)$ √© um n√∫mero imagin√°rio puro, pois $r$ √© o m√≥dulo da raiz, e $\sin(t\theta)$ √© uma fun√ß√£o trigonom√©trica que produz valores reais, e o termo est√° multiplicado por $i$.
III. Portanto, a diferen√ßa das pot√™ncias das ra√≠zes complexas conjugadas √© sempre um n√∫mero imagin√°rio puro.
‚ñ†

### Manipula√ß√£o de N√∫meros Complexos em Algoritmos

A manipula√ß√£o computacional de n√∫meros complexos pode ser feita usando bibliotecas especializadas ou com representa√ß√µes adequadas que reduzam erros de arredondamento e de propaga√ß√£o. Em python, o uso do tipo `complex` do `numpy` garante maior precis√£o e efici√™ncia. √â √∫til usar a forma polar para calcular pot√™ncias das ra√≠zes, especialmente para calcular os termos da solu√ß√£o da equa√ß√£o de diferen√ßa.

#### Problemas com Precis√£o Num√©rica
Ao manipular n√∫meros complexos usando representa√ß√µes de ponto flutuante, erros de arredondamento podem ocorrer, principalmente durante opera√ß√µes que envolvem subtra√ß√µes ou somas de n√∫meros com magnitudes muito diferentes.  Esses erros podem se acumular ao longo de itera√ß√µes, levando a resultados imprecisos ou at√© mesmo inst√°veis. Uma maneira de mitigar esses erros √© usar representa√ß√µes de alta precis√£o para n√∫meros complexos e algoritmos num√©ricos robustos.
Em particular, ao calcular os coeficientes na solu√ß√£o da equa√ß√£o de diferen√ßas, pode ser vantajoso realizar as manipula√ß√µes alg√©bricas usando express√µes anal√≠ticas o m√°ximo poss√≠vel, de modo a evitar a propaga√ß√£o de erros num√©ricos.

> üí° **Observa√ß√£o:** Em c√°lculos com n√∫meros complexos, sempre que poss√≠vel, √© recomend√°vel usar representa√ß√µes na forma polar ou realizar as opera√ß√µes analiticamente antes de calcular os resultados numericamente.

#### M√©todos para Calcular Pot√™ncias Complexas
Em algoritmos num√©ricos, o c√°lculo de $\lambda^t$ pode ser feito com a forma polar, o que evita alguns problemas de arredondamento:
1.  **Forma Polar:** Se $\lambda = re^{i\theta}$, ent√£o $\lambda^t = r^t e^{it\theta} = r^t(\cos(t\theta) + i\sin(t\theta))$.
2.  **Aproxima√ß√£o de Taylor**: Ao calcular $\cos(t\theta)$ e $\sin(t\theta)$ pode ser √∫til usar a expans√£o em s√©rie de Taylor dessas fun√ß√µes. No entanto, o truncamento da s√©rie pode gerar erros de arredondamento, e o n√∫mero de termos que devem ser considerados para uma determinada precis√£o vai depender de $t \theta$.

> üí° **Observa√ß√£o:** O uso da forma polar √© recomendado para calcular pot√™ncias complexas porque ela transforma a opera√ß√£o de exponencia√ß√£o em opera√ß√µes mais simples envolvendo exponencia√ß√£o de n√∫meros reais e fun√ß√µes trigonom√©tricas, que podem ser calculadas com algoritmos num√©ricos est√°veis.
>
> üí° **Exemplo Num√©rico:**
> Calculando $\lambda^t$ para $\lambda = 0.866e^{1.286i}$ e $t=5$:
>
> 1. Usando a forma polar:
>    $$ \lambda^5 = (0.866)^5 e^{5 \times 1.286i} = 0.483 e^{6.43i} = 0.483 (\cos(6.43) + i\sin(6.43)) \approx 0.483(-0.975 + 0.222i) \approx -0.471 + 0.107i $$
>
> 2.  Usando a representa√ß√£o retangular diretamente:
>   $$ \lambda \approx 0.25 + 0.829i $$
>   $$ \lambda^2 \approx (0.25 + 0.829i)^2 \approx 0.0625 + 0.4145i - 0.6872 \approx -0.6247+0.4145i $$
>   $$ \lambda^3 \approx (-0.6247+0.4145i)(0.25 + 0.829i) \approx  -0.156175 - 0.5179i + 0.103625i - 0.34367 \approx -0.4998 - 0.414275i $$
>   $$ \lambda^4 \approx (-0.4998 - 0.414275i)(0.25 + 0.829i) \approx -0.12495 -0.4143i -0.1036i + 0.3433 \approx 0.2184-0.5179i $$
>  $$ \lambda^5 \approx (0.2184-0.5179i)(0.25 + 0.829i) \approx 0.0546 -0.1810i + 0.1810i+0.4293 \approx 0.4839 $$
>  Note que o uso da representa√ß√£o retangular diretamente e as opera√ß√µes em ponto flutuante geram erros num√©ricos maiores.

#### Evitando Subtra√ß√µes de N√∫meros Similares
Sempre que poss√≠vel, evite subtra√ß√µes de n√∫meros similares. Esta opera√ß√£o pode levar √† perda de d√≠gitos significativos, causando imprecis√£o. Ao calcular, por exemplo, as somas de pot√™ncias $\lambda_1^t + \lambda_2^t$, a forma $2 r^t \cos(t\theta)$ usa diretamente a representa√ß√£o polar, reduzindo o risco de instabilidades num√©ricas.
Para o c√°lculo das ra√≠zes, pode ser √∫til evitar a f√≥rmula quadr√°tica diretamente, usando outras t√©cnicas para calcular as ra√≠zes de polin√¥mios como o m√©todo de Laguerre, que √© mais robusto numericamente.

#### Uso de Bibliotecas Otimizadas
Bibliotecas como `numpy` e `scipy` em python s√£o otimizadas para c√°lculos com n√∫meros complexos, oferecendo uma combina√ß√£o de efici√™ncia e precis√£o. Ao realizar opera√ß√µes num√©ricas com n√∫meros complexos, use as fun√ß√µes dessas bibliotecas, e evite implementar seu pr√≥prio c√≥digo. Essas bibliotecas tamb√©m incluem fun√ß√µes para calcular raiz de polin√¥mios que s√£o muito mais precisas do que o uso direto da f√≥rmula quadr√°tica.

> üí° **Observa√ß√£o:** Ao implementar algoritmos de solu√ß√£o de equa√ß√µes de diferen√ßas que envolvem n√∫meros complexos, utilize bibliotecas especializadas como `numpy` para garantir maior precis√£o e efici√™ncia.
>
> üí° **Exemplo Num√©rico:**
> ```python
> import numpy as np
>
> # Exemplo com as ra√≠zes do exemplo anterior
> phi1 = 0.5
> phi2 = -0.75
>
> # Calcula as ra√≠zes usando numpy
> roots = np.roots([1, -phi1, -phi2])
> print("Ra√≠zes calculadas com numpy:", roots)
>
> # Calcula o m√≥dulo e argumento das ra√≠zes
> lambda1 = roots[0]
> r = np.abs(lambda1)
> theta = np.arctan2(lambda1.imag, lambda1.real)
> print("M√≥dulo da raiz:", r)
> print("Argumento da raiz:", theta)
>
> # Calcula lambda1^5 usando a forma polar
> t = 5
> lambda1_t = r**t * np.exp(1j * t * theta)
> print("lambda1^5 usando a forma polar:", lambda1_t)
>
> # Calcula lambda1^5 diretamente
> lambda1_t_direct = lambda1**t
> print("lambda1^5 diretamente:", lambda1_t_direct)
>
> # Verifica a diferen√ßa
> diff = np.abs(lambda1_t - lambda1_t_direct)
> print("Diferen√ßa absoluta:", diff)
> ```
> Este exemplo mostra como utilizar `numpy` para calcular as ra√≠zes, obter m√≥dulo e argumento, e calcular pot√™ncias complexas. Note que a diferen√ßa entre o m√©todo com forma polar e o c√°lculo direto √© pequena, mas pode se acumular em itera√ß√µes.

### Implica√ß√µes para a Implementa√ß√£o de Algoritmos

A maneira como os n√∫meros complexos s√£o tratados em algoritmos computacionais tem implica√ß√µes diretas para a precis√£o e a estabilidade das solu√ß√µes de equa√ß√µes de diferen√ßa. √â fundamental seguir as seguintes diretrizes:

1. **Valida√ß√£o da Estabilidade:** Antes de manipular operadores inversos, √© essencial verificar a condi√ß√£o de estabilidade do sistema, ou seja, que o m√≥dulo das ra√≠zes caracter√≠sticas seja menor que 1. Quando os sistemas s√£o inst√°veis, a converg√™ncia da s√©rie n√£o √© garantida e, portanto, qualquer manipula√ß√£o num√©rica deve ser feita com extremo cuidado.
2. **An√°lise Num√©rica:** Implemente m√©todos de an√°lise num√©rica para calcular os valores das ra√≠zes complexas e manipular as s√©ries, de modo a garantir que os resultados obtidos sejam v√°lidos e que n√£o estejam contaminados por erros de arredondamento.
3.  **Forma Polar:** Utilize a forma polar para calcular pot√™ncias complexas, o que garante maior precis√£o e efici√™ncia computacional.
4.  **Algoritmos Otimizados:** Utilize bibliotecas especializadas que forne√ßam algoritmos num√©ricos robustos e precisos para calcular as ra√≠zes de polin√¥mios e realizar opera√ß√µes com n√∫meros complexos.
5.  **Testes de Robustez:** Sempre que poss√≠vel, fa√ßa testes de robustez, variando os par√¢metros do modelo, para verificar se o comportamento dos resultados √© o esperado, de modo a evitar que problemas relacionados com erros de arredondamento levem a conclus√µes incorretas.
> üí° **Observa√ß√£o:** Ao implementar algoritmos de solu√ß√£o para equa√ß√µes de diferen√ßa, implemente todas as salvaguardas num√©ricas discutidas anteriormente para minimizar erros e garantir resultados robustos e precisos.

### Implica√ß√µes Te√≥ricas
Quando as ra√≠zes de uma equa√ß√£o de diferen√ßas s√£o complexas, os resultados sobre estabilidade vistos at√© aqui devem ser interpretados com cuidado. Por exemplo, se uma raiz √© um n√∫mero complexo $a+bi$, a condi√ß√£o para estabilidade √© $|a+bi| < 1$, onde $|a+bi| = \sqrt{a^2 + b^2}$. Por outro lado, a solu√ß√£o $y_t$ apresentar√° um componente oscilat√≥rio com uma frequ√™ncia determinada pelo argumento $\theta = \arctan(\frac{b}{a})$ e uma amplitude decrescente se $|a+bi| < 1$.

**Teorema 1** A condi√ß√£o para que as ra√≠zes complexas conjugadas $\lambda_1=re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$  garantam estabilidade, ou seja,  que $\lim_{t\to\infty} \lambda_1^t + \lambda_2^t = 0$, √© que o m√≥dulo $r$ das ra√≠zes seja menor do que 1.
*Prova:*

I. A soma das pot√™ncias de $\lambda_1$ e $\lambda_2$ √© dada por $\lambda_1^t + \lambda_2^t = 2r^t \cos(t\theta)$.
II. Para que essa express√£o tenda para zero quando $t$ tende para o infinito,  o termo $r^t$ deve tender para zero.
III. O termo $\cos(t\theta)$ est√° limitado ao intervalo $[-1, 1]$, ent√£o, seu comportamento n√£o afeta a converg√™ncia do termo para zero.
IV.  A express√£o $r^t$ converge para zero se e somente se  $|r|<1$.
V. Portanto, a condi√ß√£o de estabilidade √© $|r|<1$.
‚ñ†

**Teorema 1.1** A condi√ß√£o para que a solu√ß√£o da equa√ß√£o de diferen√ßas $y_t = \phi_1 y_{t-1} + \phi_2 y_{t-2}$ seja est√°vel quando as ra√≠zes caracter√≠sticas $\lambda_1$ e $\lambda_2$ s√£o complexas conjugadas √© que o m√≥dulo dessas ra√≠zes seja menor do que 1.

*Prova:*
I. A solu√ß√£o geral da equa√ß√£o de diferen√ßas quando as ra√≠zes s√£o distintas √© dada por $y_t = c_1 \lambda_1^t + c_2 \lambda_2^t$, onde $c_1$ e $c_2$ s√£o constantes determinadas pelas condi√ß√µes iniciais.
II. Se as ra√≠zes s√£o complexas conjugadas $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$, a solu√ß√£o pode ser escrita como $y_t = c_1 r^t e^{i\theta t} + c_2 r^t e^{-i\theta t}$.
III. Usando a Proposi√ß√£o 1.1, podemos reescrever a solu√ß√£o como $y_t =  r^t (d_1 \cos(t\theta) + d_2 \sin(t\theta))$, onde $d_1$ e $d_2$ s√£o constantes.
IV.  Para que a solu√ß√£o seja est√°vel, precisamos que $\lim_{t\to\infty} y_t = 0$.
V. Como as fun√ß√µes trigonom√©tricas s√£o limitadas, a condi√ß√£o para que $\lim_{t\to\infty} r^t (d_1 \cos(t\theta) + d_2 \sin(t\theta)) = 0$ √© que $\lim_{t\to\infty} r^t = 0$.
VI. Isso ocorre se e somente se $|r| < 1$.
VII. Portanto, a condi√ß√£o para estabilidade √© que o m√≥dulo das ra√≠zes complexas seja menor do que 1.
‚ñ†

**Teorema 1.2** Se as ra√≠zes caracter√≠sticas de uma equa√ß√£o de diferen√ßas de segunda ordem s√£o complexas conjugadas $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$, e o m√≥dulo das ra√≠zes √© $r = 1$, ent√£o a solu√ß√£o da equa√ß√£o de diferen√ßas exibir√° oscila√ß√µes persistentes de amplitude constante.

*Prova:*

I. A solu√ß√£o geral da equa√ß√£o de diferen√ßas com ra√≠zes complexas conjugadas pode ser expressa como $y_t = c_1 \lambda_1^t + c_2 \lambda_2^t$, onde $c_1$ e $c_2$ s√£o constantes.
II. Usando a Proposi√ß√£o 1.1, podemos reescrever essa solu√ß√£o como $y_t = r^t (d_1 \cos(t\theta) + d_2 \sin(t\theta))$, onde $d_1$ e $d_2$ s√£o constantes determinadas pelas condi√ß√µes iniciais.
III. Se $r=1$, ent√£o a solu√ß√£o se torna $y_t = d_1 \cos(t\theta) + d_2 \sin(t\theta)$.
IV. Esta express√£o representa uma combina√ß√£o linear de fun√ß√µes seno e cosseno com frequ√™ncia $\theta$.
V. Como as fun√ß√µes trigonom√©tricas oscilam entre -1 e 1, a amplitude da solu√ß√£o permanece constante.
VI. Portanto, quando o m√≥dulo das ra√≠zes complexas conjugadas √© 1, a solu√ß√£o da equa√ß√£o de diferen√ßas exibir√° oscila√ß√µes persistentes de amplitude constante.
‚ñ†

**Teorema 1.3** Se as ra√≠zes caracter√≠sticas de uma equa√ß√£o de diferen√ßas de segunda ordem s√£o complexas conjugadas $\lambda_1 = re^{i\theta}$ e $\lambda_2 = re^{-i\theta}$, e o m√≥dulo das ra√≠zes √© $r > 1$, ent√£o a solu√ß√£o da equa√ß√£o de diferen√ßas exibir√° oscila√ß√µes com amplitude crescente.
*Prova:*

I. A solu√ß√£o geral da equa√ß√£o de diferen√ßas com ra√≠zes complexas conjugadas pode ser expressa como $y_t = c_1 \lambda_1^t + c_2 \lambda_2^t$, onde $c_1$ e $c_2$ s√£o constantes.
II. Usando a Proposi√ß√£o 1.1, podemos reescrever essa solu√ß√£o como $y_t = r^t (d_1 \cos(t\theta) + d_2 \sin(t\theta))$, onde $d_1$ e $d_2$ s√£o constantes determinadas pelas condi√ß√µes iniciais.
III. Se $r > 1$, ent√£o o termo $r^t$ crescer√° para infinito quando $t$ crescer.
IV. Portanto, a amplitude da solu√ß√£o, que √© proporcional a $r^t$, tamb√©m crescer√° para o infinito.
V. Portanto, quando o m√≥dulo das ra√≠zes complexas conjugadas √© maior que 1, a solu√ß√£o da equa√ß√£o de diferen√ßas exibir√° oscila√ß√µes com amplitude crescente.
‚ñ†

### Conclus√£o

A manipula√ß√£o de n√∫meros complexos em algoritmos para solu√ß√£o de equa√ß√µes de diferen√ßa de segunda ordem √© um aspecto essencial para garantir resultados precisos e est√°veis. As ra√≠zes complexas conjugadas emergem quando o discriminante da equa√ß√£o caracter√≠stica √© negativo, e sua manipula√ß√£o requer um cuidado especial para evitar erros num√©ricos. Ao usar a forma polar e algoritmos num√©ricos robustos e bibliotecas especializadas, como o `numpy` e `scipy` em python, podemos calcular solu√ß√µes com maior precis√£o e efici√™ncia. Al√©m disso, a interpreta√ß√£o dos resultados em termos da amplitude e da frequ√™ncia dos componentes oscilat√≥rios √© crucial para entender a din√¢mica dos sistemas modelados com equa√ß√µes de diferen√ßas.

### Refer√™ncias
[^1]:  "...An example of a time series operator is the multiplication operator..."
[^2]: "...Another example of a time series operator is the addition operator..."
[^3]: "...Consider next a second-order difference equation: $y_t = \phi_1 y_{t-1} + \phi_2 y_{t-2} + w_t$..."
[^4]: "...The eigenvalues of F were seen to be the two values of Œª that satisfy equation (Œª¬≤ ‚Äì Œ¶ŒπŒª ‚Äì Œ¶2) = 0..."
[^5]: "...Following Sargent (1987, p. 184), when Œª1 ‚â† Œª2, we can use the following operator:..."
<!-- END -->
