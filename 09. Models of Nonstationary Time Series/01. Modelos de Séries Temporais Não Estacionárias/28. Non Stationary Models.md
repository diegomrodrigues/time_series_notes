## Modelagem Computacional Avan√ßada de S√©ries Temporais N√£o Estacion√°rias

### Introdu√ß√£o
Este cap√≠tulo expande os conceitos de modelagem computacional de s√©ries temporais n√£o estacion√°rias, focando em modelos que capturam din√¢micas e depend√™ncias temporais complexas com varia√ß√£o estat√≠stica no tempo [^1], [^2], [^3], [^4], [^5]. Construindo sobre os modelos de passeio aleat√≥rio com deriva e modelos com tend√™ncia determin√≠stica linear j√° apresentados [^2], vamos explorar abordagens mais avan√ßadas para modelar a n√£o estacionaridade, incluindo modelos com componentes autoregressivos, m√©dias m√≥veis e sazonalidade, e como esses modelos permitem an√°lises e previs√µes mais precisas. O objetivo √© fornecer uma vis√£o abrangente de como a modelagem computacional permite lidar com a complexidade inerente das s√©ries temporais n√£o estacion√°rias.

### Modelagem ARMA com Componentes N√£o Estacion√°rios
Como vimos anteriormente [^2], modelos ARMA (Autorregressivo de M√©dias M√≥veis) s√£o √∫teis para modelar depend√™ncias temporais em s√©ries estacion√°rias. No entanto, quando a s√©rie apresenta n√£o estacionaridade, √© necess√°rio estender os modelos ARMA para incorporar essa caracter√≠stica. Uma abordagem comum √© utilizar modelos ARIMA (Autorregressivo Integrado de M√©dias M√≥veis), que diferenciam a s√©rie original para torn√°-la estacion√°ria, e ent√£o aplicam um modelo ARMA √† s√©rie diferenciada. Outra abordagem √© modelar o componente n√£o estacion√°rio atrav√©s de uma tend√™ncia determin√≠stica, e, ent√£o, modelar os res√≠duos com um modelo ARMA [^3], [^4].

#### Modelagem ARIMA
Modelos ARIMA s√£o uma extens√£o dos modelos ARMA, que incluem a diferencia√ß√£o da s√©rie temporal para torn√°-la estacion√°ria. Um modelo ARIMA(p, d, q) √© caracterizado por tr√™s par√¢metros:
*   `p`: a ordem da parte autorregressiva.
*   `d`: a ordem da integra√ß√£o (o n√∫mero de vezes que a s√©rie √© diferenciada).
*   `q`: a ordem da parte de m√©dias m√≥veis.
A s√©rie original $y_t$ √© diferenciada $d$ vezes para obter a s√©rie estacion√°ria $w_t$, que √© modelada por um modelo ARMA(p, q). O modelo ARIMA √© dado por:
$$ \phi(L)(1-L)^d y_t = \theta(L)\epsilon_t $$
onde $\phi(L)$ √© o operador autoregressivo, $\theta(L)$ √© o operador de m√©dias m√≥veis, e $(1-L)^d$ √© o operador de diferencia√ß√£o de ordem $d$.

##### Implementa√ß√£o em Python com Statsmodels
A biblioteca Statsmodels oferece fun√ß√µes para a implementa√ß√£o e estima√ß√£o de modelos ARIMA. A fun√ß√£o `ARIMA()` √© utilizada para construir o modelo, e a fun√ß√£o `fit()` para estimar os par√¢metros:

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt

def model_arima(y, order=(1, 1, 1)):
    """Modela uma s√©rie temporal n√£o estacion√°ria com ARIMA.
    Args:
        y (np.array): S√©rie temporal.
        order (tuple, optional): Ordem do modelo ARIMA. Defaults to (1, 1, 1).
    Returns:
        statsmodels.tsa.arima.model.ARIMAResultsWrapper: Resultados do ajuste do modelo.
    """
    try:
        y_series = pd.Series(y)
        model = ARIMA(y_series, order=order)
        model_fit = model.fit()
        print("\nModelo ARIMA ajustado:")
        print(model_fit.summary())
        return model_fit
    except Exception as e:
        print(f"Erro ao ajustar o modelo ARIMA: {e}")
        return None


# Exemplo de uso
T = 100
alpha_true = 5
delta_true = 0.2
t = np.arange(1, T + 1)
epsilon = np.random.normal(0, 1, T)
y = alpha_true + delta_true * t + epsilon
model_fit_results = model_arima(y, order=(1,1,1))

```
A fun√ß√£o `model_arima` recebe a s√©rie temporal `y` e a ordem do modelo ARIMA, ajusta o modelo, e imprime o resumo dos resultados. Os par√¢metros do modelo s√£o estimados utilizando m√©todos de m√°xima verossimilhan√ßa, e o resumo do modelo cont√©m as estimativas dos par√¢metros, os erros padr√£o, o AIC (crit√©rio de informa√ß√£o de Akaike), e outras estat√≠sticas.

> üí° **Exemplo Num√©rico:**
>
>   Vamos supor que tenhamos uma s√©rie temporal com uma tend√™ncia linear e um componente AR(1), e modelamos esta s√©rie como um processo ARIMA(1,1,1).
>  ```python
> import numpy as np
> import pandas as pd
> from statsmodels.tsa.arima.model import ARIMA
> import matplotlib.pyplot as plt
>
> def model_arima(y, order=(1, 1, 1)):
>    try:
>        y_series = pd.Series(y)
>        model = ARIMA(y_series, order=order)
>        model_fit = model.fit()
>        print("\nModelo ARIMA ajustado:")
>        print(model_fit.summary())
>        return model_fit
>    except Exception as e:
>        print(f"Erro ao ajustar o modelo ARIMA: {e}")
>        return None
>
> # Gerar dados com tend√™ncia e componente AR(1)
> np.random.seed(42)
> T = 100
> alpha_true = 5
> delta_true = 0.2
> phi = 0.7
> sigma_epsilon = 1
> epsilon = np.random.normal(0, sigma_epsilon, T)
> u = np.zeros(T)
> for t in range(1, T):
>    u[t] = phi * u[t-1] + epsilon[t]
> t = np.arange(1, T + 1)
> y = alpha_true + delta_true * t + u
>
> # Estimativa com ARIMA
> model_fit_results = model_arima(y, order=(1,1,1))
> ```
> Os resultados do ajuste do modelo ARIMA ser√£o similares a:
>
> ```
> Modelo ARIMA ajustado:
>                              ARIMA Model Results
> ==============================================================================
> Dep. Variable:                      y   No. Observations:                  100
> Model:                 ARIMA(1, 1, 1)   Log Likelihood                -138.433
> Method:                          css   S.D. of innovations              0.962
> Date:                Thu, 18 May 2024   AIC                             284.866
> Time:                        18:39:18   BIC                             292.672
> Sample:                             0   HQIC                            288.027
> ==============================================================================
>                  coef    std err          z      P>|z|      [0.025      0.975]
> ------------------------------------------------------------------------------
> ar.L1          0.7035      0.088      8.003      0.000       0.531       0.876
> ma.L1         -0.0661      0.130     -0.508      0.612      -0.321       0.189
> sigma2         0.9257      0.115      8.080      0.000       0.701       1.150
> ==============================================================================
> ```
> Os resultados indicam que o par√¢metro autoregressivo AR(1) √© estatisticamente significativo (p-valor < 0.05), enquanto o par√¢metro MA(1) n√£o √© estatisticamente significativo (p-valor > 0.05). A estat√≠stica AIC (Akaike Information Criterion) √© uma medida da qualidade do ajuste, que pode ser utilizada para comparar diferentes modelos.
>
> **Interpreta√ß√£o:** O par√¢metro `ar.L1` (0.7035) indica que o valor atual da s√©rie temporal √© influenciado pelo valor anterior, com uma depend√™ncia positiva. O par√¢metro `ma.L1` (-0.0661) √© pr√≥ximo de zero e n√£o significativo, indicando que o componente de m√©dias m√≥veis n√£o adiciona muito valor preditivo neste caso. A vari√¢ncia do erro (`sigma2`) √© 0.9257. O AIC e o BIC s√£o usados para comparar diferentes modelos; menor o valor, melhor o modelo se ajusta aos dados.

##### Implementa√ß√£o em R com o pacote `forecast`
Em R, a fun√ß√£o `arima()` do pacote `forecast` pode ser utilizada para modelar s√©ries temporais n√£o estacion√°rias. A fun√ß√£o `auto.arima()` √© capaz de selecionar automaticamente a ordem do modelo com base em crit√©rios de informa√ß√£o.

```R
library(forecast)

model_arima <- function(y, order = c(1, 1, 1)) {
  try {
    model <- arima(y, order = order)
    print("\nModelo ARIMA ajustado:")
    print(summary(model))
    return(model)
  } catch(e){
      print("Erro ao ajustar o modelo ARIMA")
      return(NULL)
  }
}

# Exemplo de uso
T <- 100
alpha_true <- 5
delta_true <- 0.2
t <- 1:T
epsilon <- rnorm(T, mean = 0, sd = 1)
y <- alpha_true + delta_true * t + epsilon
model_fit_results <- model_arima(y, order = c(1,1,1))
```
A fun√ß√£o `model_arima` recebe a s√©rie temporal `y` e a ordem do modelo ARIMA, ajusta o modelo, e imprime o resumo dos resultados. A sa√≠da do modelo ARIMA em R √© similar √† sa√≠da do modelo em Python.

#### Modelos ARMA com Tend√™ncia Determin√≠stica
Outra abordagem para modelar s√©ries n√£o estacion√°rias √© incluir uma tend√™ncia determin√≠stica na equa√ß√£o da m√©dia, e modelar o componente estoc√°stico com um modelo ARMA. A representa√ß√£o √© dada por:
$$ y_t = \alpha + \delta t + u_t $$
onde $u_t$ segue um processo ARMA(p, q), dado por:
$$ \phi(L)u_t = \theta(L)\epsilon_t $$
Essa abordagem √© similar √† modelagem de modelos "trend-stationary", mas ela tamb√©m pode ser aplicada em modelos com raiz unit√°ria, pois a tend√™ncia determin√≠stica pode capturar a deriva na s√©rie.
A estima√ß√£o dos par√¢metros pode ser feita atrav√©s de m√≠nimos quadrados para os par√¢metros da tend√™ncia linear ($\alpha$ e $\delta$), e atrav√©s de m√°xima verossimilhan√ßa para os par√¢metros do modelo ARMA para os res√≠duos.

##### Implementa√ß√£o em Python
A implementa√ß√£o em Python pode ser feita utilizando a fun√ß√£o `detrend_linear()` j√° definida anteriormente, e, em seguida, aplicando a fun√ß√£o `ARIMA()` da biblioteca `statsmodels` aos res√≠duos:

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt

def detrend_linear(y):
    """Remove a tend√™ncia linear de uma s√©rie temporal.
    Args:
        y (np.array): S√©rie temporal.
    Returns:
      tuple: (detrended_series, alpha_hat, delta_hat)
            detrended_series (np.array): S√©rie temporal sem a tend√™ncia linear.
            alpha_hat (float): Estimativa do intercepto.
            delta_hat (float): Estimativa da inclina√ß√£o.
    """
    T = len(y)
    time = np.arange(1, T + 1)
    X = np.column_stack((np.ones(T), time))
    beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]
    alpha_hat = beta_hat[0]
    delta_hat = beta_hat[1]
    trend = alpha_hat + delta_hat * time
    detrended_series = y - trend
    return detrended_series, alpha_hat, delta_hat

def model_arma_with_trend(y, order=(1,0,1)):
    """Modela uma s√©rie temporal n√£o estacion√°ria com ARMA e tend√™ncia linear.
    Args:
        y (np.array): S√©rie temporal.
        order (tuple, optional): Ordem do modelo ARMA. Defaults to (1, 0, 1).
    Returns:
        statsmodels.tsa.arima.model.ARIMAResultsWrapper: Resultados do ajuste do modelo.
    """
    detrended_series, alpha_hat, delta_hat = detrend_linear(y)
    print(f"Estimated alpha: {alpha_hat:.4f}")
    print(f"Estimated delta: {delta_hat:.4f}")
    try:
        detrended_series_series = pd.Series(detrended_series)
        model = ARIMA(detrended_series_series, order=order)
        model_fit = model.fit()
        print("\nModelo ARMA ajustado nos res√≠duos:")
        print(model_fit.summary())
        return model_fit
    except Exception as e:
        print(f"Erro ao ajustar o modelo ARMA: {e}")
        return None


# Exemplo de uso
T = 100
alpha_true = 5
delta_true = 0.2
t = np.arange(1, T + 1)
epsilon = np.random.normal(0, 1, T)
y = alpha_true + delta_true * t + epsilon
model_fit_results = model_arma_with_trend(y, order=(1,0,1))

```
A fun√ß√£o `model_arma_with_trend` recebe a s√©rie temporal, aplica a fun√ß√£o `detrend_linear` para remover a tend√™ncia linear, e ent√£o aplica a fun√ß√£o `ARIMA` aos res√≠duos, com ordem definida, para modelar o componente estoc√°stico com ARMA. Os resultados incluem as estimativas de $\alpha$ e $\delta$ obtidas com a remo√ß√£o da tend√™ncia, e as estat√≠sticas do modelo ARMA ajustado aos res√≠duos.

> üí° **Exemplo Num√©rico:**
>
> Suponha que temos uma s√©rie gerada com uma tend√™ncia linear e um componente estoc√°stico AR(1), dada por $y_t = 5 + 0.2t + u_t$, onde $u_t = 0.6u_{t-1} + \epsilon_t$.
>
>  ```python
> import numpy as np
> import pandas as pd
> from statsmodels.tsa.arima.model import ARIMA
> import matplotlib.pyplot as plt
>
> def detrend_linear(y):
>    T = len(y)
>    time = np.arange(1, T + 1)
>    X = np.column_stack((np.ones(T), time))
>    beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]
>    alpha_hat = beta_hat[0]
>    delta_hat = beta_hat[1]
>    trend = alpha_hat + delta_hat * time
>    detrended_series = y - trend
>    return detrended_series, alpha_hat, delta_hat
>
> def model_arma_with_trend(y, order=(1,0,1)):
>    detrended_series, alpha_hat, delta_hat = detrend_linear(y)
>    print(f"Estimated alpha: {alpha_hat:.4f}")
>    print(f"Estimated delta: {delta_hat:.4f}")
>    try:
>        detrended_series_series = pd.Series(detrended_series)
>        model = ARIMA(detrended_series_series, order=order)
>        model_fit = model.fit()
>        print("\nModelo ARMA ajustado nos res√≠duos:")
>        print(model_fit.summary())
>        return model_fit
>    except Exception as e:
>        print(f"Erro ao ajustar o modelo ARMA: {e}")
>        return None
>
> # Gerar dados com tend√™ncia e componente AR(1)
> np.random.seed(42)
> T = 100
> alpha_true = 5
> delta_true = 0.2
> phi = 0.6
> sigma_epsilon = 1
> epsilon = np.random.normal(0, sigma_epsilon, T)
> u = np.zeros(T)
> for t in range(1, T):
>    u[t] = phi * u[t-1] + epsilon[t]
> t = np.arange(1, T + 1)
> y = alpha_true + delta_true * t + u
>
> # Ajustar o modelo
> model_fit_results = model_arma_with_trend(y, order=(1,0,1))
> ```
> A sa√≠da do c√≥digo ser√° similar a:
>
> ```
> Estimated alpha: 4.749
> Estimated delta: 0.202
>
> Modelo ARMA ajustado nos res√≠duos:
>                              ARMA Model Results
> ==============================================================================
> Dep. Variable:                      y   No. Observations:                  100
> Model:                    ARMA(1, 1)   Log Likelihood                -138.595
> Method:                          css   S.D. of innovations              0.961
> Date:                Thu, 18 May 2024   AIC                             283.190
> Time:                        18:52:44   BIC                             290.997
> Sample:                             0
> HQIC                            286.351
> ==============================================================================
>                  coef    std err          z      P>|z|      [0.025      0.975]
> ------------------------------------------------------------------------------
> ar.L1          0.6162      0.078      7.884      0.000       0.463       0.769
> ma.L1          0.0061      0.118      0.052      0.959      -0.226       0.238
> sigma2         0.9232      0.109      8.439      0.000       0.709       1.137
> ==============================================================================
> ```
> Os resultados incluem a estimativa da tend√™ncia linear ($\alpha$ e $\delta$), e as estat√≠sticas do modelo ARMA ajustado aos res√≠duos. A estimativa de $\alpha$ √© pr√≥xima de 5, e a estimativa de $\delta$ √© pr√≥xima de 0.2, que s√£o os par√¢metros verdadeiros utilizados na simula√ß√£o. O par√¢metro AR(1) √© estatisticamente significativo, enquanto o par√¢metro MA(1) n√£o √© estatisticamente significativo.
>
> **Interpreta√ß√£o:** O modelo primeiro estima a tend√™ncia linear, onde $\alpha$ √© o intercepto (4.749) e $\delta$ √© a inclina√ß√£o (0.202). Ap√≥s remover a tend√™ncia linear, um modelo ARMA(1,1) √© ajustado aos res√≠duos. O coeficiente `ar.L1` (0.6162) indica uma depend√™ncia positiva dos res√≠duos em rela√ß√£o aos valores defasados. O coeficiente `ma.L1` (0.0061) √© pr√≥ximo de zero, indicando que o termo MA n√£o contribui significativamente para o modelo dos res√≠duos.

##### Implementa√ß√£o em R
A implementa√ß√£o em R pode ser feita utilizando a fun√ß√£o `lm()` para estimar a tend√™ncia linear, e ent√£o aplicando a fun√ß√£o `arima()` aos res√≠duos:
```R
library(forecast)

detrend_linear <- function(y) {
  T <- length(y)
  time <- 1:T
  X <- cbind(1, time)
  model <- lm(y ~ X - 1)
  alpha_hat <- coef(model)[1]
  delta_hat <- coef(model)[2]
  trend <- alpha_hat + delta_hat * time
  detrended_series <- y - trend
  return(list(detrended_series = detrended_series, alpha_hat = alpha_hat, delta_hat = delta_hat))
}

model_arma_with_trend <- function(y, order = c(1, 0, 1)) {
  result <- detrend_linear(y)
  detrended_series <- result$detrended_series
  alpha_hat <- result$alpha_hat
  delta_hat <- result$delta_hat
  print(paste("Estimated alpha:", alpha_hat))
  print(paste("Estimated delta:", delta_hat))
  try {
    model <- arima(detrended_series, order = order)
      print("\nModelo ARMA ajustado nos res√≠duos:")
      print(summary(model))
      return(model)
    } catch(e){
        print("Erro ao ajustar o modelo ARMA")
        return(NULL)
    }

}

# Exemplo de uso
T <- 100
alpha_true <- 5
delta_true <- 0.2
t <- 1:T
epsilon <- rnorm(T, mean = 0, sd = 1)
y <- alpha_true + delta_true * t + epsilon
model_fit_results <- model_arma_with_trend(y, order = c(1,0,1))

```
A fun√ß√£o `model_arma_with_trend` recebe a s√©rie temporal, aplica a fun√ß√£o `detrend_linear` para remover a tend√™ncia linear, e ent√£o aplica a fun√ß√£o `arima()` aos res√≠duos, com ordem definida, para modelar o componente estoc√°stico. Os resultados incluem as estimativas de $\alpha$ e $\delta$, e as estat√≠sticas do modelo ARMA ajustado aos res√≠duos.

### Modelagem de Sazonalidade em S√©ries Temporais N√£o Estacion√°rias
Muitas s√©ries temporais exibem padr√µes sazonais que se repetem em intervalos regulares de tempo, como trimestres, meses ou dias da semana. A modelagem da sazonalidade √© um passo importante para obter previs√µes mais precisas em s√©ries temporais n√£o estacion√°rias, e requer o uso de modelos que sejam capazes de capturar esses padr√µes peri√≥dicos, como os modelos SARIMA (Seasonal ARIMA).

#### Modelos SARIMA
Modelos SARIMA s√£o uma extens√£o dos modelos ARIMA que incluem a modelagem da sazonalidade. Um modelo SARIMA(p, d, q)(P, D, Q)s √© caracterizado por sete par√¢metros:
*   `p`: a ordem da parte autorregressiva n√£o sazonal.
*   `d`: a ordem da integra√ß√£o n√£o sazonal (o n√∫mero de vezes que a s√©rie √© diferenciada n√£o sazonalmente).
*   `q`: a ordem da parte de m√©dias m√≥veis n√£o sazonal.
*   `P`: a ordem da parte autorregressiva sazonal.
*   `D`: a ordem da integra√ß√£o sazonal (o n√∫mero de vezes que a s√©rie √© diferenciada sazonalmente).
*   `Q`: a ordem da parte de m√©dias m√≥veis sazonal.
*   `s`: o per√≠odo sazonal.
O modelo SARIMA combina componentes autorregressivos, componentes de m√©dias m√≥veis, e componentes de diferencia√ß√£o, tanto sazonais como n√£o sazonais. O modelo √© dado por:
$$ \phi(L)\Phi(L^s)(1-L)^d (1-L^s)^D y_t = \theta(L)\Theta(L^s)\epsilon_t $$
onde $\phi(L)$ √© o operador autorregressivo n√£o sazonal, $\Phi(L^s)$ √© o operador autorregressivo sazonal, $\theta(L)$ √© o operador de m√©dias m√≥veis n√£o sazonal, $\Theta(L^s)$ √© o operador de m√©dias m√≥veis sazonal, $(1-L)^d$ √© o operador de diferencia√ß√£o n√£o sazonal de ordem $d$, $(1-L^s)^D$ √© o operador de diferencia√ß√£o sazonal de ordem $D$, e $s$ √© o per√≠odo sazonal.
##### Implementa√ß√£o em Python com Statsmodels
A biblioteca Statsmodels oferece fun√ß√µes para a implementa√ß√£o e estima√ß√£o de modelos SARIMA. A fun√ß√£o `SARIMAX()` (Seasonal AutoRegressive Integrated Moving Average with eXogenous regressors) √© utilizada para construir o modelo, e a fun√ß√£o `fit()` para estimar os par√¢metros.

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
import matplotlib.pyplot as plt

def model_sarima(y, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12)):
  """Modela uma s√©rie temporal n√£o estacion√°ria e sazonal com SARIMA.
  Args:
        y (np.array): S√©rie temporal.
        order (tuple, optional): Ordem do modelo ARIMA. Defaults to (1, 1, 1).
        seasonal_order (tuple, optional): Ordem sazonal do modelo ARIMA. Defaults to (1, 1, 1, 12).
  Returns:
        statsmodels.tsa.statespace.sarimax.SARIMAXResultsWrapper: Resultados do ajuste do modelo.
  """
  try:
        y_series = pd.Series(y)
        model = SARIMAX(y_series, order=order, seasonal_order=seasonal_order)
        model_fit = model.fit()
        print("\nModelo SARIMA ajustado:")
        print(model_fit.summary())
        return model_fit
  except Exception as e:
        print(f"Erro ao ajustar o modelo SARIMA: {e}")
        return None

# Example of use:
T = 150
s = 12 # Seasonal period
alpha_true = 10
delta_true = 0.05
sigma_epsilon = 1
np.random.seed(42)
epsilon = np.random.normal(0, sigma_epsilon, T)
t = np.arange(1, T + 1)
seasonal_component = 2 * np.sin(2 * np.pi * t / s)
y = alpha_true + delta_true * t + seasonal_component + epsilon
model_fit_results = model_sarima(y, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12))

```
A fun√ß√£o `model_sarima` recebe a s√©rie temporal, a ordem n√£o sazonal e a ordem sazonal, e ajusta o modelo SARIMA usando m√°xima verossimilhan√ßa. O resumo do modelo inclui as estat√≠sticas, os par√¢metros estimados, os erros padr√£o e outros par√¢metros.

> üí° **Exemplo Num√©rico:**
>
>  Vamos simular uma s√©rie temporal com uma tend√™ncia linear, um componente sazonal e um ru√≠do branco, e, ent√£o, modelar essa s√©rie com SARIMA.
>
> ```python
> import numpy as np
> import pandas as pd
> from statsmodels.tsa.statespace.sarimax import SARIMAX
> import matplotlib.pyplot as plt
>
> def model_sarima(y, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12)):
>  try:
>        y_series = pd.Series(y)
>        model = SARIMAX(y_series, order=order, seasonal_order=seasonal_order)
>        model_fit = model.fit()
>        print("\nModelo SARIMA ajustado:")
>        print(model_fit.summary())
>        return model_fit
>  except Exception as e:
>        print(f"Erro ao ajustar o modelo SARIMA: {e}")
>        return None
>
> # Gerar dados com tend√™ncia e componente sazonal
> np.random.seed(42)
> T = 150
> s = 12 # Seasonal period
> alpha_true = 10
> delta_true = 0.05
> sigma_epsilon = 1
> epsilon = np.random.normal(0, sigma_epsilon, T)
> t = np.arange(1, T + 1)
> seasonal_component = 2 * np.sin(2 * np.pi * t / s)
> y = alpha_true + delta_true * t + seasonal_component + epsilon
>
> model_fit_results = model_sarima(y, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12))
> ```
> A sa√≠da do c√≥digo ser√° similar a:
>
> ```
> Modelo SARIMA ajustado:
>                                      SARIMAX Results
> ==============================================================================
> Dep. Variable:                      y   No. Observations:                  150
> Model:             SARIMAX(1, 1, 1)x(1, 1, 1, 12)   Log Likelihood                -212.378
> Method:                          css   S.D. of innovations              0.825
> Date:                Thu, 18 May 2024   AIC                             438.757
> Time:                        19:12:11   BIC                             456.800
> Sample:                             0   HQIC                            446.112
> ==============================================================================
>                  coef    std err          z      P>|z|      [0.025      0.975]
> ------------------------------------------------------------------------------
> ar.L1         -0.1456      0.094     -1.553      0.120      -0.330       0.038
> ma.L1         -0.8569      0.061    -14.030      0.000      -0.977      -0.737
> ar.S.L12      -0.4383      0.078     -5.592      0.000      -0.592      -0.285
> ma.S.L12      -0.9850      0.023    -42.162      0.000      -1.031      -0.939
> sigma2         0.6811      0.093      7.341      0.000       0.500       0.863
> ==============================================================================
> ```
> Os resultados mostram a estimativa dos par√¢metros do modelo SARIMA, incluindo os par√¢metros autoregressivos e de m√©dias m√≥veis n√£o sazonais e sazonais, bem como a vari√¢ncia do ru√≠do.
>
> **Interpreta√ß√£o:** O modelo SARIMA(1,1,1)(1,1,1,12) ajusta tanto componentes sazonais quanto n√£o sazonais. O coeficiente `ar.L1` (-0.1456) e `ma.L1` (-0.8569) representam os componentes n√£o sazonais, onde `ma.L1` √© significativo. Os coeficientes `ar.S.L12` (-0.4383) e `ma.S.L12` (-0.9850) representam os componentes sazonais, ambos sendo altamente significativos. O par√¢metro `sigma2` (0.6811) √© a vari√¢ncia do erro.

##### Implementa√ß√£o em R com o pacote `forecast`

Em R, a fun√ß√£o `arima()` ou `auto.arima()` do pacote `forecast` pode ser utilizada para modelar s√©ries temporais sazonais. No entanto, o pacote `forecast` tamb√©m oferece a fun√ß√£o `sarima()` que implementa diretamente o modelo SARIMA:
```R
library(forecast)

model_sarima <- function(y, order = c(1, 1, 1), seasonal = c(1, 1, 1, 12)) {
  try {
    model <- arima(y, order = order, seasonal = list(order = seasonal))
    print("\nModelo SARIMA ajustado:")
    print(summary(model))
    return(model)
  } catch(e){
      print("Erro ao ajustar o modelo SARIMA")
      return(NULL)
  }
}

# Example of use
T <- 150
s <- 12 # Seasonal period
alpha_true <- 10
delta_true <- 0.05
sigma_epsilon <- 1
set.seed(42)
epsilon <- rnorm(T, mean = 0, sd = sigma_epsilon)
t <- 1:T
seasonal_component <- 2 * sin(2 * pi * t / s)
y <- alpha_true + delta_true * t + seasonal_component + epsilon
model_fit_results <- model_sarima(y, order = c(1,1,1), seasonal = c(1,1,1,12))
```
A fun√ß√£o `model_sarima` recebe a s√©rie temporal `y`, a ordem n√£o sazonal `order` e a ordem sazonal `seasonal`, e ajusta o modelo SARIMA.

### M√©todos de Otimiza√ß√£o em Modelos N√£o Estacion√°rios
A estima√ß√£o de par√¢metros em modelos n√£o estacion√°rios, incluindo modelos ARIMA, modelos ARMA com tend√™ncia determin√≠stica, e modelos SARIMA, requer o uso de m√©todos de otimiza√ß√£o para encontrar os par√¢metros que melhor se ajustam aos dados. O m√©todo de m√°xima verossimilhan√ßa (MLE) √© frequentemente utilizado para esse fim.
A fun√ß√£o de verossimilhan√ßa √© constru√≠da com base na distribui√ß√£o de probabilidade dos erros, que geralmente s√£o assumidos como independentes e identicamente distribu√≠dos com distribui√ß√£o normal de m√©dia zero e vari√¢ncia constante.
A fun√ß√£o de verossimilhan√ßa √© ent√£o maximizada em rela√ß√£o aos par√¢metros do modelo, atrav√©s do uso de algoritmos de otimiza√ß√£o num√©rica.

#### Implementa√ß√£o em Python com SciPy
A biblioteca SciPy oferece a fun√ß√£o `scipy.optimize.minimize()`, que pode ser usada para implementar a otimiza√ß√£o num√©rica da fun√ß√£o de verossimilhan√ßa. No entanto, a biblioteca Statsmodels implementa fun√ß√µes otimizadas para a estima√ß√£o de modelos ARMA e ARIMA, que s√£o mais eficientes e f√°ceis de usar. O algoritmo utilizado na fun√ß√£o fit() da classe ARIMA da biblioteca Statsmodels √© o algoritmo de m√°xima verossimilhan√ßa condicional, que usa uma aproxima√ß√£o da fun√ß√£o de verossimilhan√ßa.

#### Implementa√ß√£o em R
Em R, a fun√ß√£o `optim()` pode ser usada para maximizar a fun√ß√£o de verossimilhan√ßa definida pelo usu√°rio. No entanto, os pacotes `forecast` e `stats` oferecem fun√ß√µes otimizadas para a estima√ß√£o de modelos ARIMA e SARIMA. A fun√ß√£o `arima()` usa um algoritmo de otimiza√ß√£o que utiliza a aproxima√ß√£o da fun√ß√£o de verossimilhan√ßa condicional. A fun√ß√£o `auto.arima()` utiliza um algoritmo para selecionar a ordem do modelo que minimiza o AIC.

### Simula√ß√£o de Modelos N√£o Estacion√°rios
A simula√ß√£o de modelos n√£o estacion√°rios √© crucial para a valida√ß√£o de modelos, para a an√°lise da distribui√ß√£o dosestimadores e para estudos de cen√°rios futuros.

#### Simula√ß√£o de um passeio aleat√≥rio com deriva
Um passeio aleat√≥rio com deriva √© um processo n√£o estacion√°rio, caracterizado por um deslocamento m√©dio constante a cada per√≠odo, al√©m do movimento aleat√≥rio. Ele √© definido como:

$X_t = c + X_{t-1} + \epsilon_t$,

onde $c$ √© a deriva e $\epsilon_t$ √© um ru√≠do branco.

Vamos simular este modelo e observar seu comportamento.

```python
import numpy as np
import matplotlib.pyplot as plt

def random_walk_with_drift(n, c, sigma):
    """Simula um passeio aleat√≥rio com deriva.
    
    Args:
        n (int): N√∫mero de passos.
        c (float): Deriva.
        sigma (float): Desvio padr√£o do ru√≠do.

    Returns:
        np.array: S√©rie temporal simulada.
    """
    x = np.zeros(n)
    for t in range(1, n):
        x[t] = c + x[t-1] + np.random.normal(0, sigma)
    return x

# Par√¢metros
n = 100
c = 0.2
sigma = 1

# Simula√ß√£o
serie = random_walk_with_drift(n, c, sigma)

# Visualiza√ß√£o
plt.plot(serie)
plt.xlabel("Tempo")
plt.ylabel("Valor")
plt.title("Simula√ß√£o de Passeio Aleat√≥rio com Deriva")
plt.show()
```

Neste c√≥digo, definimos uma fun√ß√£o `random_walk_with_drift` para simular o processo. Podemos ajustar os par√¢metros `n`, `c`, e `sigma` para observar diferentes comportamentos da s√©rie. A deriva `c` influencia a tend√™ncia geral da s√©rie, enquanto o desvio padr√£o `sigma` controla a dispers√£o do ru√≠do.

#### Simula√ß√£o de um modelo AR n√£o estacion√°rio
Modelos AR podem se tornar n√£o estacion√°rios se suas ra√≠zes caracter√≠sticas estiverem fora do c√≠rculo unit√°rio. Por exemplo, um AR(1) definido por

$X_t = \phi_1 X_{t-1} + \epsilon_t$

√© n√£o estacion√°rio se $|\phi_1| \geq 1$. Vamos simular um AR(1) com $\phi_1 = 1.1$ e observar o comportamento da s√©rie.

```python
def ar1_unstable(n, phi1, sigma):
    """Simula um AR(1) n√£o estacion√°rio.

    Args:
        n (int): N√∫mero de passos.
        phi1 (float): Coeficiente AR(1).
        sigma (float): Desvio padr√£o do ru√≠do.
    Returns:
       np.array: S√©rie temporal simulada.
    """
    x = np.zeros(n)
    for t in range(1, n):
        x[t] = phi1 * x[t-1] + np.random.normal(0, sigma)
    return x

# Par√¢metros
n = 100
phi1 = 1.1
sigma = 1

# Simula√ß√£o
serie = ar1_unstable(n, phi1, sigma)

# Visualiza√ß√£o
plt.plot(serie)
plt.xlabel("Tempo")
plt.ylabel("Valor")
plt.title("Simula√ß√£o de AR(1) N√£o Estacion√°rio")
plt.show()
```

Este c√≥digo simula um AR(1) com $\phi_1 = 1.1$, um valor que gera n√£o estacionaridade. O gr√°fico mostrar√° um comportamento explosivo, t√≠pico de s√©ries n√£o estacion√°rias.

### Previs√£o com Modelos ARIMA
Modelos ARIMA (AutoRegressive Integrated Moving Average) s√£o uma classe de modelos que acomodam tanto a autocorrela√ß√£o quanto a n√£o estacionaridade em s√©ries temporais. Eles s√£o definidos por tr√™s par√¢metros: (p, d, q), onde:
*   p: ordem da parte auto regressiva (AR).
*   d: ordem da diferencia√ß√£o necess√°ria para tornar a s√©rie estacion√°ria.
*   q: ordem da parte de m√©dias m√≥veis (MA).

#### Processo de Previs√£o
O processo de previs√£o usando um modelo ARIMA envolve os seguintes passos:
1.  Identifica√ß√£o: determinar as ordens (p, d, q) do modelo. Isso √© feito geralmente analisando as fun√ß√µes de autocorrela√ß√£o (ACF) e autocorrela√ß√£o parcial (PACF) da s√©rie.
2.  Estimativa: estimar os par√¢metros do modelo com base nos dados hist√≥ricos.
3.  Valida√ß√£o: avaliar o desempenho do modelo nos dados de valida√ß√£o.
4.  Previs√£o: usar o modelo para prever valores futuros.

Vamos realizar uma previs√£o usando um modelo ARIMA para os dados simulados anteriormente com passeio aleat√≥rio com deriva.

```python
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA

# Simula√ß√£o de dados
n = 100
c = 0.2
sigma = 1
serie = random_walk_with_drift(n, c, sigma)
df = pd.DataFrame(serie, columns=['data'])


# Divis√£o em treino e teste
train_data = df['data'][:80]
test_data = df['data'][80:]

# Modelo ARIMA
model = ARIMA(train_data, order=(0, 1, 0))
model_fit = model.fit()

# Previs√£o
predictions = model_fit.predict(start=len(train_data), end=len(df)-1)

# Visualiza√ß√£o
plt.plot(df['data'], label='Real')
plt.plot(train_data.index, train_data, label="Treino")
plt.plot(test_data.index, predictions, label='Previs√£o')
plt.xlabel("Tempo")
plt.ylabel("Valor")
plt.title("Previs√£o com ARIMA")
plt.legend()
plt.show()
```
Neste c√≥digo, usamos a biblioteca `statsmodels` para implementar um modelo ARIMA(0,1,0). A ordem d=1 significa que estamos usando a primeira diferen√ßa da s√©rie para torn√°-la estacion√°ria. O modelo √© ajustado aos dados de treinamento e ent√£o usado para prever os dados de teste.

### Conclus√£o
Este cap√≠tulo abordou m√©todos para simula√ß√£o e previs√£o de modelos de s√©ries temporais. A simula√ß√£o √© essencial para entender o comportamento dos modelos em diversas condi√ß√µes e validar suas premissas. A previs√£o, por sua vez, permite usar modelos para fazer proje√ß√µes futuras e auxiliar em tomadas de decis√£o. Modelos ARIMA s√£o uma ferramenta poderosa para trabalhar com s√©ries temporais n√£o estacion√°rias e podem ser adaptados para diversos contextos.

<!-- END -->
