## Testes de Raiz Unit√°ria: Desafios e Interpreta√ß√µes na Presen√ßa da Equival√™ncia Observacional

### Introdu√ß√£o
Nos cap√≠tulos anteriores, exploramos os fundamentos dos modelos de s√©ries temporais n√£o estacion√°rias, detalhando modelos com tend√™ncia, modelos com raiz unit√°ria e modelos estacion√°rios. Vimos como esses modelos se diferenciam nas suas transforma√ß√µes para estacionariedade, previs√µes, multiplicadores din√¢micos e no tratamento de choques. Discutimos, ainda, a equival√™ncia observacional entre modelos com raiz unit√°ria e estacion√°rios, que levanta quest√µes fundamentais sobre a validade de testes estat√≠sticos em amostras finitas. Neste cap√≠tulo, vamos nos concentrar nos testes de raiz unit√°ria, ferramentas cruciais para identificar se uma s√©rie temporal possui uma raiz unit√°ria e, portanto, √© n√£o estacion√°ria. Analisaremos como a equival√™ncia observacional afeta a interpreta√ß√£o desses testes e quais s√£o as implica√ß√µes pr√°ticas para a modelagem e an√°lise de s√©ries temporais. O objetivo √© fornecer uma compreens√£o detalhada dos desafios e limita√ß√µes associados aos testes de raiz unit√°ria, capacitando os analistas a interpretar os resultados com mais cautela e precis√£o.

### Conceitos Fundamentais
#### A Necessidade dos Testes de Raiz Unit√°ria
Testes de raiz unit√°ria s√£o usados para determinar se uma s√©rie temporal possui uma raiz unit√°ria, o que indica a presen√ßa de n√£o estacionariedade [^11]. A presen√ßa de uma raiz unit√°ria implica que choques na s√©rie t√™m efeitos permanentes, alterando seu n√≠vel de forma cont√≠nua ao longo do tempo e que, portanto, a s√©rie n√£o retorna a sua m√©dia, ao contr√°rio de s√©ries estacion√°rias [^12]. A detec√ß√£o da presen√ßa de uma raiz unit√°ria √© fundamental para uma modelagem apropriada e para evitar resultados esp√∫rios ao trabalhar com s√©ries temporais n√£o estacion√°rias.

Os testes de raiz unit√°ria s√£o projetados para verificar se o coeficiente autorregressivo de uma s√©rie temporal √© igual a 1, que √© a condi√ß√£o para a presen√ßa de uma raiz unit√°ria. Formalmente, a hip√≥tese nula $H_0$ √© que existe uma raiz unit√°ria e que $\phi = 1$ em um modelo autoregressivo AR(1) como:
$$
y_t = \phi y_{t-1} + \epsilon_t
$$
Onde $\phi = 1$ sob a hip√≥tese nula e $\phi < 1$ sob a hip√≥tese alternativa.

#### Teste de Dickey-Fuller (DF)
Um dos testes de raiz unit√°ria mais utilizados √© o teste de Dickey-Fuller (DF) [^11]. O teste DF testa se uma s√©rie temporal tem uma raiz unit√°ria ou n√£o. Esse teste √© realizado por meio da estima√ß√£o da regress√£o:

$$ \Delta y_t = \alpha + \beta y_{t-1} + \epsilon_t $$

Onde $\Delta y_t = y_t - y_{t-1}$, e o teste avalia se o coeficiente $\beta$ √© estatisticamente diferente de zero. Se $\beta = 0$, ent√£o $\phi = 1$, e a s√©rie possui uma raiz unit√°ria, indicando que a s√©rie √© n√£o estacion√°ria. Se $\beta \neq 0$, ent√£o $\phi = \beta+1 \neq 1$, e a s√©rie √© estacion√°ria. A hip√≥tese nula do teste √© que $\beta = 0$, ou seja, que a s√©rie possui uma raiz unit√°ria.

> üí° **Exemplo Num√©rico:** Vamos considerar uma s√©rie temporal simulada $y_t$ com 100 observa√ß√µes, gerada por um processo AR(1) com $\phi = 0.9$.
> ```python
> import numpy as np
> import pandas as pd
> import statsmodels.api as sm
>
> np.random.seed(42)
> n = 100
> phi = 0.9
> epsilon = np.random.normal(0, 1, n)
> y = np.zeros(n)
> y[0] = np.random.normal(0, 1)
> for t in range(1, n):
>    y[t] = phi * y[t-1] + epsilon[t]
>
> df = pd.DataFrame({'y': y})
> df['y_lag'] = df['y'].shift(1)
> df = df.dropna()
> df['delta_y'] = df['y'] - df['y_lag']
>
> X = df['y_lag']
> X = sm.add_constant(X)
> y_reg = df['delta_y']
>
> model = sm.OLS(y_reg, X)
> results = model.fit()
> print(results.summary())
> ```
> O c√≥digo acima gera uma s√©rie temporal $y_t$ e estima o modelo de Dickey-Fuller $\Delta y_t = \alpha + \beta y_{t-1} + \epsilon_t$. A sa√≠da do summary incluir√° o valor estimado de $\beta$ e seu p-valor. Digamos que o resultado seja $\hat{\beta} = -0.095$ com um p-valor < 0.05. Isso significa que rejeitamos a hip√≥tese nula de que $\beta = 0$ (e, portanto, a s√©rie n√£o tem uma raiz unit√°ria) ao n√≠vel de signific√¢ncia de 5%. Assim, para esta amostra em particular, o teste DF indicaria que a s√©rie $y_t$ √© estacion√°ria. Se o p-valor fosse alto (e.g., p-valor > 0.10), n√£o rejeitar√≠amos a hip√≥tese nula, indicando que a s√©rie poderia ter uma raiz unit√°ria.
>
> Em contraste, se simul√°ssemos uma s√©rie com raiz unit√°ria ($\phi=1$), o valor estimado de $\beta$ seria muito pr√≥ximo de 0 e ter√≠amos um p-valor grande. Por exemplo, simulando um passeio aleat√≥rio ($\phi = 1$):
> ```python
> np.random.seed(42)
> n = 100
> phi = 1
> epsilon = np.random.normal(0, 1, n)
> y = np.zeros(n)
> y[0] = np.random.normal(0, 1)
> for t in range(1, n):
>    y[t] = phi * y[t-1] + epsilon[t]
>
> df = pd.DataFrame({'y': y})
> df['y_lag'] = df['y'].shift(1)
> df = df.dropna()
> df['delta_y'] = df['y'] - df['y_lag']
>
> X = df['y_lag']
> X = sm.add_constant(X)
> y_reg = df['delta_y']
>
> model = sm.OLS(y_reg, X)
> results = model.fit()
> print(results.summary())
> ```
> Neste caso, poder√≠amos obter $\hat{\beta} = -0.01$ com um p-valor > 0.10. N√£o rejeitar√≠amos a hip√≥tese nula de que a s√©rie possui raiz unit√°ria.

#### Teste de Dickey-Fuller Aumentado (ADF)
Uma extens√£o do teste DF √© o teste de Dickey-Fuller Aumentado (ADF). O teste ADF considera que a s√©rie pode ter um componente autorregressivo de ordem maior que 1. Para fazer isso, o teste ADF adiciona lags da diferen√ßa da s√©rie √† regress√£o:
$$
\Delta y_t = \alpha + \beta y_{t-1} + \sum_{i=1}^{p} \gamma_i \Delta y_{t-i} + \epsilon_t
$$
Onde $\gamma_i$ s√£o coeficientes dos lags da diferen√ßa da s√©rie e $p$ √© o n√∫mero de lags inclu√≠dos na regress√£o. O teste ADF, assim como o DF, testa a hip√≥tese nula de que $\beta = 0$, ou seja, que a s√©rie possui uma raiz unit√°ria.

**Observa√ß√£o 8.1** (Escolha do N√∫mero de Lags no ADF)
A escolha do n√∫mero de lags ($p$) no teste ADF √© um aspecto crucial. Um n√∫mero insuficiente de lags pode levar a resultados enviesados, enquanto um n√∫mero excessivo de lags pode reduzir a pot√™ncia do teste. Em geral, √© importante usar crit√©rios de informa√ß√£o (como AIC ou BIC) para determinar o n√∫mero √≥timo de lags.

> üí° **Exemplo Num√©rico:** Suponha que a s√©rie $y_t$ seja gerada pelo modelo:
> $$
> y_t = 1.1 y_{t-1} - 0.2 y_{t-2} + \epsilon_t
> $$
> Vamos simular uma s√©rie temporal de 200 observa√ß√µes com este processo:
> ```python
> import numpy as np
> import pandas as pd
> import statsmodels.api as sm
> from statsmodels.tsa.stattools import adfuller
>
> np.random.seed(42)
> n = 200
> y = np.zeros(n)
> epsilon = np.random.normal(0, 1, n)
> y[0] = np.random.normal(0,1)
> y[1] = np.random.normal(0,1)
>
> for t in range(2, n):
>  y[t] = 1.1 * y[t-1] - 0.2 * y[t-2] + epsilon[t]
>
> adf_result = adfuller(y,regression='c', maxlag = 3) # 'c' inclui constante, maxlag = 3 para escolher um numero de lags
> print("Estat√≠stica ADF:", adf_result[0])
> print("p-valor:", adf_result[1])
> print("Lags usados:", adf_result[2])
> print("Valores cr√≠ticos:", adf_result[4])
> ```
>  Para testar se a s√©rie possui uma raiz unit√°ria atrav√©s do teste ADF, estimamos a regress√£o:
> $$
> \Delta y_t = \alpha + \beta y_{t-1} + \gamma_1 \Delta y_{t-1} + \epsilon_t
> $$
> onde $\Delta y_t = y_t - y_{t-1}$.  Usamos a fun√ß√£o `adfuller` do `statsmodels`, que faz a regress√£o com os lags automaticamente. O output da fun√ß√£o mostra a estat√≠stica ADF, o p-valor, o n√∫mero de lags usados e os valores cr√≠ticos em diferentes n√≠veis de signific√¢ncia. Se o p-valor retornado pelo teste for menor que 0.05 (ou 0.10), rejeitamos a hip√≥tese nula de que a s√©rie possui raiz unit√°ria. Caso contr√°rio, n√£o rejeitamos a hip√≥tese nula, o que significa que a s√©rie pode ter uma raiz unit√°ria.

#### Outros Testes de Raiz Unit√°ria
Al√©m dos testes DF e ADF, existem outros testes de raiz unit√°ria, como o teste de Phillips-Perron (PP) e o teste de Kwiatkowski-Phillips-Schmidt-Shin (KPSS). Os testes PP e KPSS utilizam diferentes abordagens para lidar com problemas de autocorrela√ß√£o e heterocedasticidade nos erros, oferecendo alternativas aos testes DF e ADF.

- **Teste de Phillips-Perron (PP):** O teste PP √© uma alternativa n√£o param√©trica ao teste ADF. Ele permite que a distribui√ß√£o do erro seja mais flex√≠vel e robusta, e corrige a estat√≠stica de teste para poss√≠veis heterocedasticidades e autocorrela√ß√µes nos erros.
- **Teste de Kwiatkowski-Phillips-Schmidt-Shin (KPSS):** Diferentemente dos testes anteriores, o teste KPSS tem como hip√≥tese nula que a s√©rie √© estacion√°ria. Ele busca testar a hip√≥tese nula de estacionaridade, ao inv√©s de testar a hip√≥tese nula de raiz unit√°ria.

**Observa√ß√£o 8.2** (Hip√≥tese Nula nos Testes)
√â importante observar que os testes DF, ADF e PP testam a hip√≥tese nula de que a s√©rie possui uma raiz unit√°ria, enquanto o teste KPSS testa a hip√≥tese nula de que a s√©rie √© estacion√°ria. Essa diferen√ßa na formula√ß√£o da hip√≥tese nula leva a diferentes interpreta√ß√µes dos resultados do teste, e deve ser considerada na escolha do teste a ser usado.

**Proposi√ß√£o 8.1** (Rela√ß√£o entre os Testes PP e ADF)
O teste de Phillips-Perron (PP) pode ser considerado uma alternativa ao teste de Dickey-Fuller Aumentado (ADF) quando h√° suspeita de que os res√≠duos do modelo apresentam autocorrela√ß√£o ou heterocedasticidade. Em ess√™ncia, o teste PP ajusta a estat√≠stica do teste de Dickey-Fuller (DF) para levar em conta poss√≠veis depend√™ncias nos res√≠duos, sem a necessidade de adicionar lags adicionais, como no ADF.

*Prova:*
I. O teste DF padr√£o assume que os res√≠duos do modelo s√£o ru√≠do branco.
II. O teste ADF corrige poss√≠veis autocorrela√ß√µes adicionando lags da vari√°vel dependente, o que equivale a um modelo AR nos res√≠duos.
III. O teste PP corrige o problema de depend√™ncia nos res√≠duos atrav√©s de uma corre√ß√£o n√£o param√©trica na estat√≠stica de teste, sem a necessidade de especificar a estrutura de autocorrela√ß√£o nos res√≠duos.
IV. Em termos assint√≥ticos, ambos os testes convergem para os mesmos resultados se os res√≠duos do modelo s√£o bem modelados pelo ajuste do ADF, com um n√∫mero suficiente de lags. Em amostras finitas, a corre√ß√£o n√£o param√©trica do teste PP pode tornar o teste mais robusto do que o ADF quando a estrutura de autocorrela√ß√£o nos res√≠duos n√£o √© bem conhecida ou quando os lags a serem inclu√≠dos no ADF s√£o dif√≠ceis de escolher.
V. Portanto, ambos os testes s√£o projetados para testar a mesma hip√≥tese, mas lidam com o problema da autocorrela√ß√£o de maneiras diferentes. $\blacksquare$

> üí° **Exemplo Num√©rico:** Vamos usar os dados simulados anteriormente para ilustrar os testes PP e KPSS. Primeiro simulamos os dados.
> ```python
> import numpy as np
> import pandas as pd
> import statsmodels.api as sm
> from statsmodels.tsa.stattools import adfuller, kpss
> from statsmodels.tsa.filters.filtertools import phillips_perron
>
> np.random.seed(42)
> n = 200
> y = np.zeros(n)
> epsilon = np.random.normal(0, 1, n)
> y[0] = np.random.normal(0,1)
> y[1] = np.random.normal(0,1)
>
> for t in range(2, n):
>  y[t] = 1.1 * y[t-1] - 0.2 * y[t-2] + epsilon[t]
> ```
> Agora podemos realizar os testes de Phillips-Perron e KPSS.
> ```python
> pp_result = phillips_perron(y,regression='c')
> print("Teste Phillips-Perron:")
> print("Estat√≠stica PP:", pp_result[0])
> print("p-valor:", pp_result[1])
>
> kpss_result = kpss(y, regression='c', nlags = 'auto')
> print("\nTeste KPSS:")
> print("Estat√≠stica KPSS:", kpss_result[0])
> print("p-valor:", kpss_result[1])
> print("Lags usados:", kpss_result[2])
> ```
> O teste PP retorna uma estat√≠stica e um p-valor. Se o p-valor for menor que 0.05 (ou 0.10), rejeitamos a hip√≥tese nula de que a s√©rie possui raiz unit√°ria. O teste KPSS, por outro lado, tem como hip√≥tese nula a estacionariedade. Portanto, se o p-valor for menor que 0.05, rejeitamos a hip√≥tese nula de estacionariedade, o que indica que a s√©rie pode ter uma raiz unit√°ria.

#### A Equival√™ncia Observacional e a Interpreta√ß√£o dos Testes de Raiz Unit√°ria
Como discutido no cap√≠tulo anterior, a equival√™ncia observacional entre modelos com raiz unit√°ria e processos estacion√°rios com ra√≠zes pr√≥ximas de 1 torna dif√≠cil a distin√ß√£o entre esses modelos em amostras finitas [^11]. Processos estacion√°rios com alta persist√™ncia, que podem ser representados por um modelo AR(1) com um coeficiente autoregressivo $\phi$ muito pr√≥ximo de 1 (e.g. 0.99), podem se comportar de forma muito semelhante a um passeio aleat√≥rio, que tem uma raiz unit√°ria e $\phi = 1$. A consequ√™ncia disso √© que os testes de raiz unit√°ria podem falhar em distinguir entre esses dois processos, ou seja, podem apresentar baixa pot√™ncia [^11].

A baixa pot√™ncia dos testes de raiz unit√°ria em amostras finitas significa que, mesmo quando a hip√≥tese nula √© falsa (ou seja, quando a s√©rie √© estacion√°ria), o teste pode n√£o conseguir rejeit√°-la com uma probabilidade razo√°vel (erro do tipo II). Al√©m disso, o teste tamb√©m pode rejeitar a hip√≥tese nula quando ela √© verdadeira (erro do tipo I). Os testes de raiz unit√°ria, portanto, podem fornecer evid√™ncias amb√≠guas ou enganosas, e seus resultados devem ser interpretados com cautela [^11].

> üí° **Exemplo Num√©rico:** Vamos simular duas s√©ries temporais: uma que √© um passeio aleat√≥rio ($y_t = y_{t-1} + \epsilon_t$) e outra que √© um processo AR(1) estacion√°rio com $\phi = 0.99$ ($y_t = 0.99y_{t-1} + \epsilon_t$). Em seguida, aplicaremos o teste ADF em ambas as s√©ries e verificaremos a frequ√™ncia em que a hip√≥tese nula de raiz unit√°ria √© rejeitada.

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.stattools import adfuller

np.random.seed(42)
num_simulations = 1000
n = 100
sigma_sq = 1
phi = 0.99

def simulate_and_test(process_type, n, num_simulations, sigma_sq, phi):
    rejections = 0
    for _ in range(num_simulations):
        epsilon = np.random.normal(0, np.sqrt(sigma_sq), n)
        y = np.zeros(n)
        y[0] = 0
        if process_type == 'rw':
            for t in range(1, n):
                y[t] = y[t-1] + epsilon[t]
        elif process_type == 'ar1':
            for t in range(1, n):
                y[t] = phi*y[t-1] + epsilon[t]
        adf_result = adfuller(y)
        if adf_result[1] < 0.05:
            rejections += 1
    return rejections / num_simulations

rejection_rate_rw = simulate_and_test('rw', n, num_simulations, sigma_sq, phi)
rejection_rate_ar1 = simulate_and_test('ar1', n, num_simulations, sigma_sq, phi)

print(f"Taxa de rejei√ß√£o da hip√≥tese nula para Passeio Aleat√≥rio: {rejection_rate_rw:.2f}")
print(f"Taxa de rejei√ß√£o da hip√≥tese nula para AR(1) com phi=0.99: {rejection_rate_ar1:.2f}")
```

Como a s√©rie AR(1) apresenta comportamento semelhante ao de uma s√©rie com raiz unit√°ria em amostras finitas, o teste ADF rejeita a hip√≥tese nula com menor frequ√™ncia para o passeio aleat√≥rio do que para o AR(1). Isso demonstra o erro tipo I e tipo II dos testes de raiz unit√°ria com amostras finitas. O resultado ilustra como a equival√™ncia observacional afeta a interpreta√ß√£o dos resultados dos testes de raiz unit√°ria, j√° que um modelo estacion√°rio, na pr√°tica, muitas vezes pode se comportar como um modelo com raiz unit√°ria.

**Lema 8.1** (Limita√ß√µes dos Testes de Raiz Unit√°ria em Amostras Finitas)
Em amostras finitas, os testes de raiz unit√°ria podem ter baixa pot√™ncia, especialmente quando o processo alternativo √© um processo estacion√°rio com um coeficiente autorregressivo pr√≥ximo de 1.

*Prova:*
I. A pot√™ncia de um teste estat√≠stico √© definida como a probabilidade de rejeitar corretamente a hip√≥tese nula quando ela √© falsa.
II. No caso de testes de raiz unit√°ria, a hip√≥tese nula √© a presen√ßa de uma raiz unit√°ria, e a hip√≥tese alternativa √© que a s√©rie √© estacion√°ria.
III. A equival√™ncia observacional demonstra que modelos com raiz unit√°ria e processos estacion√°rios com alta persist√™ncia podem se comportar de maneira semelhante em amostras finitas, o que implica que a fun√ß√£o de verossimilhan√ßa √© muito parecida entre esses dois processos.
IV. Como resultado da equival√™ncia observacional, a distribui√ß√£o da estat√≠stica de teste sob a hip√≥tese nula e a hip√≥tese alternativa s√£o muito semelhantes quando o coeficiente autoregressivo √© pr√≥ximo de 1, reduzindo a capacidade de o teste discriminar os dois casos.
V. Portanto, em amostras finitas, os testes de raiz unit√°ria podem ter baixa pot√™ncia e podem levar a erros de tipo II, concluindo que a hip√≥tese nula de raiz unit√°ria n√£o pode ser rejeitada mesmo quando ela √© falsa. $\blacksquare$

**Lema 8.2** (Efeito do Tamanho da Amostra na Pot√™ncia dos Testes de Raiz Unit√°ria)
A pot√™ncia dos testes de raiz unit√°ria aumenta com o tamanho da amostra.

*Prova:*
I. Com o aumento do tamanho da amostra, a vari√¢ncia das estimativas dos par√¢metros do modelo diminui, permitindo uma estima√ß√£o mais precisa do coeficiente autorregressivo.
II. Com uma estima√ß√£o mais precisa, a estat√≠stica de teste torna-se mais eficiente em distinguir entre a hip√≥tese nula (raiz unit√°ria) e a hip√≥tese alternativa (estacionariedade).
III.  Em amostras pequenas, a vari√¢ncia das estimativas √© maior e a distribui√ß√£o da estat√≠stica de teste sob a hip√≥tese nula e alternativa s√£o muito parecidas. No entanto, √† medida que o tamanho da amostra aumenta, a distribui√ß√£o da estat√≠stica de teste sob a hip√≥tese alternativa se desloca para a esquerda, longe da distribui√ß√£o sob a hip√≥tese nula, o que implica que a √°rea da rejei√ß√£o da hip√≥tese nula (i.e., a pot√™ncia do teste) √© maior.
IV. Portanto, com o aumento do tamanho da amostra, a capacidade dos testes de raiz unit√°ria em rejeitar corretamente a hip√≥tese nula quando ela √© falsa aumenta, elevando a pot√™ncia do teste. $\blacksquare$

#### Implica√ß√µes Pr√°ticas para a Modelagem
A dificuldade em distinguir entre modelos com raiz unit√°ria e modelos estacion√°rios com alta persist√™ncia tem implica√ß√µes pr√°ticas para a modelagem. Primeiro, os resultados dos testes de raiz unit√°ria devem ser interpretados com cautela. A decis√£o de modelar uma s√©rie como um processo com raiz unit√°ria ou como um processo estacion√°rio n√£o deve se basear unicamente nos resultados desses testes, mas deve levar em considera√ß√£o o conhecimento econ√¥mico e te√≥rico sobre a natureza da s√©rie [^11].

Segundo, em muitos casos, a distin√ß√£o entre modelos com raiz unit√°ria e modelos estacion√°rios pode ser mais uma quest√£o de conveni√™ncia para simplificar a modelagem do que uma verdade absoluta sobre o processo gerador de dados. A escolha do modelo deve ser guiada por uma combina√ß√£o de evid√™ncias estat√≠sticas, conhecimento te√≥rico, parcim√¥nia e objetivos da an√°lise. Se a teoria econ√¥mica indica que choques devem ter efeitos permanentes, um modelo com raiz unit√°ria pode ser mais apropriado. No entanto, se a teoria sugere que choques devem ter efeitos transit√≥rios, um modelo estacion√°rio com alta persist√™ncia (mas sem raiz unit√°ria) pode ser uma op√ß√£o melhor.

**Observa√ß√£o 8.3** (Modelagem Baseada em Conhecimento)
Em situa√ß√µes de equival√™ncia observacional, √© fundamental que a modelagem seja guiada pelo conhecimento te√≥rico e econ√¥mico, em vez de depender exclusivamente de testes estat√≠sticos. A modelagem deve ser vista como um processo de aproxima√ß√£o da realidade, e n√£o como a busca por uma verdade absoluta sobre o processo gerador de dados.

#### Transforma√ß√µes e o Uso da Diferencia√ß√£o
√â crucial notar que o uso da diferencia√ß√£o, como discutido anteriormente, para estacionarizar modelos com raiz unit√°ria, pode trazer problemas se usado inadequadamente em s√©ries *trend-stationary* [^10]. A diferencia√ß√£o de uma s√©rie trend-stationary pode resultar em um modelo n√£o invert√≠vel, que n√£o tem uma representa√ß√£o √∫nica e pode complicar a modelagem e interpreta√ß√£o dos resultados. O uso adequado da diferencia√ß√£o depende da natureza n√£o estacion√°ria da s√©rie, o que ressalta a import√¢ncia da escolha do modelo adequado.

**Lema 8.3** (Implica√ß√µes da Diferencia√ß√£o em S√©ries Trend-Stationary)
Aplicar diferencia√ß√£o a uma s√©rie *trend-stationary* resulta em uma s√©rie n√£o estacion√°ria, onde uma raiz unit√°ria √© adicionada ao componente de m√©dia m√≥vel, gerando um problema de n√£o invertibilidade e dificultando a modelagem.
*Prova:*
I. Seja $y_t = \alpha + \delta t + \psi(L)\epsilon_t$ uma s√©rie *trend-stationary*.
II. A primeira diferen√ßa √© dada por $\Delta y_t = y_t - y_{t-1}$.
III. Substituindo a equa√ß√£o de $y_t$, temos $\Delta y_t =  \delta + \psi(L)\epsilon_t - L\psi(L)\epsilon_t$.
IV. Simplificando, temos $\Delta y_t =  \delta + (1-L)\psi(L)\epsilon_t$.
V.  O termo $(1-L)$ adicionado ao componente de m√©dia m√≥vel resulta em uma raiz unit√°ria na parte da m√©dia m√≥vel do processo, o que implica que o processo n√£o √© invert√≠vel e que o componente da m√©dia m√≥vel n√£o tem uma representa√ß√£o √∫nica. $\blacksquare$

#### M√©todos Alternativos de Modelagem

Diante dos desafios associados aos testes de raiz unit√°ria, algumas abordagens alternativas de modelagem podem ser consideradas, como:

- **Modelos com Quebras Estruturais:** Incorporam quebras abruptas na tend√™ncia da s√©rie ao longo do tempo, em vez de assumir uma tend√™ncia constante, que pode ser mais apropriado para s√©ries temporais com mudan√ßas de regime.
- **Modelos de Integra√ß√£o Fracion√°ria:** Permitem a modelagem de s√©ries temporais com mem√≥ria longa, que se encontram em algum ponto entre o estacion√°rio e o com raiz unit√°ria.

A escolha entre esses m√©todos depender√° da natureza espec√≠fica dos dados e dos objetivos da an√°lise.

**Teorema 8.1** (Representa√ß√£o Alternativa de Modelos com Quebras Estruturais)
Modelos com quebras estruturais podem ser representados utilizando fun√ß√µes indicadoras, que s√£o vari√°veis bin√°rias que assumem o valor 1 durante um per√≠odo de quebra e 0 nos demais per√≠odos, que podem capturar mudan√ßas abruptas no n√≠vel ou na tend√™ncia da s√©rie temporal. Formalmente, seja $y_t$ uma s√©rie temporal, com quebra estrutural no per√≠odo $T_b$. O modelo pode ser representado como:
$$y_t = \alpha_1 + \delta_1 t + (\alpha_2 - \alpha_1)D_t + (\delta_2 - \delta_1)tD_t + \phi(L) \epsilon_t $$
Onde:
- $D_t = 1$ se $t \geq T_b$ e $0$ caso contr√°rio;
- $\alpha_1$ √© o intercepto antes da quebra;
- $\delta_1$ √© a tend√™ncia antes da quebra;
- $\alpha_2$ √© o intercepto ap√≥s a quebra;
- $\delta_2$ √© a tend√™ncia ap√≥s a quebra;
- $\phi(L)$ √© um polin√¥mio defasado.

*Prova:*
I. Seja $y_t = \alpha_1 + \delta_1 t + \phi(L) \epsilon_t$ para $t < T_b$.
II. Seja $y_t = \alpha_2 + \delta_2 t + \phi(L) \epsilon_t$ para $t \geq T_b$.
III. Podemos escrever um √∫nico modelo, utilizando a fun√ß√£o indicadora $D_t$, que se torna igual a 1 ap√≥s a quebra e igual a 0 antes, como $y_t = \alpha_1 + \delta_1 t + (\alpha_2 - \alpha_1)D_t + (\delta_2 - \delta_1)tD_t + \phi(L) \epsilon_t $.
IV. Note que quando $t < T_b$, temos $D_t = 0$ e o modelo se torna $y_t = \alpha_1 + \delta_1 t + \phi(L) \epsilon_t$.
V. Quando $t \geq T_b$, temos $D_t = 1$ e o modelo se torna $y_t = \alpha_1 + \delta_1 t + \alpha_2 - \alpha_1 + (\delta_2 - \delta_1)t +  \phi(L) \epsilon_t = \alpha_2 + \delta_2 t + \phi(L) \epsilon_t$.
VI. Portanto, o modelo com fun√ß√µes indicadoras pode ser usado para representar a quebra estrutural em s√©ries temporais. $\blacksquare$

### Conclus√£o
Os testes de raiz unit√°ria s√£o ferramentas valiosas para a an√°lise de s√©ries temporais n√£o estacion√°rias, mas a sua interpreta√ß√£o deve ser feita com cautela. A equival√™ncia observacional entre modelos com raiz unit√°ria e processos estacion√°rios com ra√≠zes pr√≥ximas de 1, especialmente em amostras finitas, resulta em testes de baixa pot√™ncia, o que pode levar a conclus√µes err√¥neas sobre a presen√ßa ou aus√™ncia de uma raiz unit√°ria. A modelagem de s√©ries temporais deve ser guiada n√£o apenas por resultados estat√≠sticos, mas tamb√©m por conhecimento te√≥rico, e a decis√£o sobre qual modelo escolher pode ser uma quest√£o de conveni√™ncia para simplificar a an√°lise, ao inv√©s de uma verdade absoluta sobre o processo gerador de dados. Abordagens alternativas podem ser consideradas, como modelos com quebras estruturais ou modelos de integra√ß√£o fracion√°ria, dependendo das caracter√≠sticas espec√≠ficas dos dados e dos objetivos da an√°lise. √â fundamental ter presente que n√£o h√° um modelo universal para todas as s√©ries temporais, e o papel do analista √© o de escolher a representa√ß√£o que melhor se ajusta a sua realidade com base em evid√™ncias te√≥ricas e emp√≠ricas.

### Refer√™ncias
[^10]: Cap√≠tulo 15, Se√ß√£o 15.3, subse√ß√£o "Transformations to Achieve Stationarity"
[^11]: Cap√≠tulo 15, Se√ß√£o 15.4 "The Meaning of Tests for Unit Roots"
[^12]: Cap√≠tulo 15, Se√ß√£o 15.3, subse√ß√£o "Comparison of Dynamic Multipliers"
<!-- END -->
